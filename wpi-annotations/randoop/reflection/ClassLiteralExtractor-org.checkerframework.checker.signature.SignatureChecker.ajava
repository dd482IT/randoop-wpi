package randoop.reflection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import randoop.operation.NonreceiverTerm;
import randoop.operation.TypedOperation;
import randoop.sequence.Sequence;
import randoop.sequence.Variable;
import randoop.types.ClassOrInterfaceType;
import randoop.util.ClassFileConstants;
import randoop.util.MultiMap;

/**
 * {@code ClassLiteralExtractor} is a {@link ClassVisitor} that extracts literals from the bytecode
 * of each class visited, adding a sequence for each to a map associating a sequence with a type.
 *
 * @see OperationModel
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
class ClassLiteralExtractor extends DefaultClassVisitor {

    private @org.checkerframework.checker.signature.qual.SignatureUnknown MultiMap<ClassOrInterfaceType, Sequence> literalMap;

    ClassLiteralExtractor(@org.checkerframework.checker.signature.qual.SignatureUnknown MultiMap<ClassOrInterfaceType, Sequence> literalMap) {
        this.literalMap = literalMap;
    }

    public void visitBefore(@org.checkerframework.checker.signature.qual.SignatureUnknown ClassLiteralExtractor this, @org.checkerframework.checker.signature.qual.SignatureUnknown Class<?> c) {
        Collection<ClassFileConstants.ConstantSet> constList = Collections.singletonList(ClassFileConstants.getConstants(c.getName()));
        MultiMap<Class<?>, NonreceiverTerm> constantMap = ClassFileConstants.toMap(constList);
        for (Class<?> constantClass : constantMap.keySet()) {
            ClassOrInterfaceType constantType = ClassOrInterfaceType.forClass(constantClass);
            for (NonreceiverTerm term : constantMap.getValues(constantClass)) {
                Sequence seq = new Sequence().extend(TypedOperation.createNonreceiverInitialization(term), new ArrayList<Variable>(0));
                literalMap.add(constantType, seq);
            }
        }
    }
}
