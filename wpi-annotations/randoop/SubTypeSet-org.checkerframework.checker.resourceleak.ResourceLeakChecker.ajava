package randoop;

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;
import randoop.types.Type;
import randoop.util.CheckpointingMultiMap;
import randoop.util.CheckpointingSet;
import randoop.util.IMultiMap;
import randoop.util.MultiMap;

/**
 * A set of classes. This data structure additionally allows for efficient answers to queries about
 * can-be-used-as relationships.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class SubTypeSet {

    /**
     * The members of the set.
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Set<Type> types;

    /**
     * Maps a type to all its proper subtypes that are in the set. If the mapped-to list is empty,
     * then the set contains no subtypes of the given type.
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) IMultiMap<Type, Type> subTypes;

    /**
     * If true, then {@link #mark} and {@link #undoLastStep()} are supported.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean supportsCheckpoints;

    public SubTypeSet( @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean supportsCheckpoints) {
        if (supportsCheckpoints) {
            this.supportsCheckpoints = true;
            this.subTypes = new CheckpointingMultiMap<>();
            this.types = new CheckpointingSet<>();
        } else {
            this.supportsCheckpoints = false;
            this.subTypes = new MultiMap<>();
            this.types = new LinkedHashSet<>();
        }
    }

    /**
     * Checkpoint the state of the data structure, for use by {@link #undoLastStep()}.
     */
    public void mark() {
        if (!supportsCheckpoints) {
            throw new RuntimeException("Operation not supported.");
        }
        ((CheckpointingMultiMap<Type, Type>) subTypes).mark();
        ((CheckpointingSet<Type>) types).mark();
    }

    /**
     * Undo changes since the last call to {@link #mark()}.
     */
    public void undoLastStep() {
        if (!supportsCheckpoints) {
            throw new RuntimeException("Operation not supported.");
        }
        ((CheckpointingMultiMap<Type, Type>) subTypes).undoToLastMark();
        ((CheckpointingSet<Type>) types).undoToLastMark();
    }

    /**
     * Adds a type to this set.
     *
     * @param c the type to be added
     */
    public void add(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SubTypeSet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isClassOrInterfaceType" }) Type c) {
        if (c == null)
            throw new IllegalArgumentException("c cannot be null.");
        if (types.contains(c)) {
            return;
        }
        types.add(c);
        // Update existing entries.
        for (Type cls : subTypes.keySet()) {
            if (cls.isAssignableFrom(c)) {
                if (!subTypes.getValues(cls).contains(c)) {
                    subTypes.add(cls, c);
                }
            }
        }
    }

    private void addQueryType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SubTypeSet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type type) {
        if (type == null)
            throw new IllegalArgumentException("c cannot be null.");
        Set<Type> keySet = subTypes.keySet();
        if (keySet.contains(type)) {
            return;
        }
        Set<Type> compatibleTypes = new LinkedHashSet<>();
        for (Type t : types) {
            if (type.isAssignableFrom(t)) {
                compatibleTypes.add(t);
            }
        }
        for (Type cls : compatibleTypes) {
            subTypes.add(type, cls);
        }
    }

    // TODO: I think that the set does not contain {@code c} itself.  Check and document.
    /**
     * Returns all the classes in the set that can-be-used-as the given {@code c}.
     *
     * @param type the query type
     * @return the set of types that can be used in place of the query type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "addQueryType" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.subTypes" }, methods = { "getValues" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Set<Type> getMatches(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SubTypeSet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type type) {
        if (!subTypes.keySet().contains(type)) {
            addQueryType(type);
        }
        return Collections.unmodifiableSet(subTypes.getValues(type));
    }

    /**
     * Returns the number of elements of this set.
     *
     * @return the size of the set
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.types" }, methods = { "size" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int size(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SubTypeSet this) {
        return types.size();
    }
}
