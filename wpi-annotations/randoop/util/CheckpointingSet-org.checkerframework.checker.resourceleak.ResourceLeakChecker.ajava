package randoop.util;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

/**
 * A Set that supports settingcheckpoints (also called "marks") and restoring the data structure's
 * state to them.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class CheckpointingSet<E> implements Set<E> {

    // This uses a MultiMap just because that is an existing checkpointing data structure.
    // The value is always true in this mapping, never false.
    public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingMultiMap<E, Boolean> map;

    public CheckpointingSet() {
        this.map = new CheckpointingMultiMap<>();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "contains" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "<init>", "add", "add_bare", "containsKey" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean add(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, E elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        if (contains(elt))
            throw new IllegalArgumentException("set already contains elt " + elt);
        return map.add(elt, Boolean.TRUE);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "containsKey" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean contains(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        return map.containsKey(elt);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "<init>", "remove", "remove_bare" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean remove(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object elt) {
        if (elt == null) {
            throw new IllegalArgumentException("arg cannot be null.");
        }
        E eltCasted = (E) elt;
        return map.remove(eltCasted, Boolean.TRUE);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "size" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int size(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        return map.size();
    }

    /**
     * Checkpoint the state of the data structure, for use by {@link #undoToLastMark()}.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "mark" })
    public void mark(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        map.mark();
    }

    /**
     * Undo changes since the last call to {@link #mark()}.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "undoLastOp", "undoToLastMark" })
    public void undoToLastMark(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        map.undoToLastMark();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.map" }, methods = { "keySet" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        return map.keySet().toString();
    }

    @org.checkerframework.dataflow.qual.Pure
    public void clear(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean addAll(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<? extends E> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean removeAll(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean retainAll(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean containsAll(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public <T> T[] toArray(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this, T @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] a) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public Object[] toArray(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public Iterator<E> iterator(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean isEmpty(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CheckpointingSet<E> this) {
        // return map.isEmpty();
        throw new UnsupportedOperationException("not yet implemented");
    }
}
