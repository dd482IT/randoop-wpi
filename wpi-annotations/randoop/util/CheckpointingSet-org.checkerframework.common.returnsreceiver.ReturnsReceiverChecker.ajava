package randoop.util;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

/**
 * A Set that supports settingcheckpoints (also called "marks") and restoring the data structure's
 * state to them.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker")
public class CheckpointingSet<E> implements Set<E> {

    // This uses a MultiMap just because that is an existing checkpointing data structure.
    // The value is always true in this mapping, never false.
    public final  CheckpointingMultiMap<E, Boolean> map;

    public CheckpointingSet() {
        this.map = new CheckpointingMultiMap<>();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean add( CheckpointingSet<E> this, E elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        if (contains(elt))
            throw new IllegalArgumentException("set already contains elt " + elt);
        return map.add(elt, Boolean.TRUE);
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean contains( CheckpointingSet<E> this,  Object elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        return map.containsKey(elt);
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean remove( CheckpointingSet<E> this,  Object elt) {
        if (elt == null) {
            throw new IllegalArgumentException("arg cannot be null.");
        }
        E eltCasted = (E) elt;
        return map.remove(eltCasted, Boolean.TRUE);
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int size( CheckpointingSet<E> this) {
        return map.size();
    }

    /**
     * Checkpoint the state of the data structure, for use by {@link #undoToLastMark()}.
     */
    public void mark( CheckpointingSet<E> this) {
        map.mark();
    }

    /**
     * Undo changes since the last call to {@link #mark()}.
     */
    public void undoToLastMark( CheckpointingSet<E> this) {
        map.undoToLastMark();
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public  String toString( CheckpointingSet<E> this) {
        return map.keySet().toString();
    }

    @org.checkerframework.dataflow.qual.Pure
    public void clear( CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean addAll( CheckpointingSet<E> this,  Collection<? extends E> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean removeAll( CheckpointingSet<E> this,  Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean retainAll( CheckpointingSet<E> this,  Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean containsAll( CheckpointingSet<E> this,  Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public <T> T[] toArray( CheckpointingSet<E> this, T  [] a) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public Object[] toArray( CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public Iterator<E> iterator( CheckpointingSet<E> this) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean isEmpty( CheckpointingSet<E> this) {
        // return map.isEmpty();
        throw new UnsupportedOperationException("not yet implemented");
    }
}
