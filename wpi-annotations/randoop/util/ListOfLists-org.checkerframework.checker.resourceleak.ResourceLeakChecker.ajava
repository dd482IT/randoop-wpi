package randoop.util;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import randoop.main.RandoopBug;

/**
 * Given a list of lists, defines methods that can access all the elements as if they were part of a
 * single list, without actually merging the lists.
 *
 * <p>This class is used for performance reasons. We want the ability to select elements collected
 * across several lists, but we observed that creating a brand new list (i.e. via a sequence of
 * List.addAll(..) operations can be very expensive, because it happened in a hot spot (method
 * SequenceCollection.getSequencesThatYield).
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class ListOfLists<E> implements SimpleList<E>, Serializable {

    private static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long serialVersionUID = -3307714585442970263L;

    /**
     * The lists themselves.
     */
    public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<SimpleList<E>> lists;

    /**
     * The i-th value is the number of elements in the sublists up to the i-th one, inclusive.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] cumulativeSize;

    /**
     * The size of this collection.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int totalelements;

    /**
     * Create a ListOfLists from ... a list of lists.
     *
     * @param lists the lists that will compose the newly-created ListOfLists
     */
    public ListOfLists(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SimpleList<E>@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ... lists) {
        this.lists = Arrays.asList(lists);
        this.cumulativeSize = new int[lists.length];
        this.totalelements = 0;
        for (int i = 0; i < lists.length; i++) {
            SimpleList<E> l = lists[i];
            if (l == null) {
                throw new IllegalArgumentException("All lists should be non-null");
            }
            this.totalelements += l.size();
            this.cumulativeSize[i] = this.totalelements;
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "size" })
    public ListOfLists(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<SimpleList<E>> lists) {
        if (lists == null)
            throw new IllegalArgumentException("param cannot be null");
        this.lists = lists;
        this.cumulativeSize = new int[lists.size()];
        this.totalelements = 0;
        for (int i = 0; i < lists.size(); i++) {
            SimpleList<E> l = lists.get(i);
            this.totalelements += l.size();
            this.cumulativeSize[i] = this.totalelements;
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int size(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this) {
        return this.totalelements;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isEmpty(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this) {
        return this.totalelements == 0;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.lists" }, methods = { "get" })
    @org.checkerframework.dataflow.qual.Deterministic
    public E get(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int index) {
        if (index < 0 || index > this.totalelements - 1) {
            throw new IllegalArgumentException("index must be between 0 and size()-1");
        }
        int previousListSize = 0;
        for (int i = 0; i < this.cumulativeSize.length; i++) {
            if (index < this.cumulativeSize[i]) {
                return this.lists.get(i).get(index - previousListSize);
            }
            previousListSize = this.cumulativeSize[i];
        }
        throw new RandoopBug("Indexing error in ListOfLists");
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.lists" }, methods = { "get" })
    @org.checkerframework.dataflow.qual.Deterministic
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SimpleList<E> getSublist(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int index) {
        if (index < 0 || index > this.totalelements - 1) {
            throw new IllegalArgumentException("index must be between 0 and size()-1");
        }
        int previousListSize = 0;
        for (int i = 0; i < this.cumulativeSize.length; i++) {
            if (index < this.cumulativeSize[i]) {
                // Recurse.
                return lists.get(i).getSublist(index - previousListSize);
            }
            previousListSize = cumulativeSize[i];
        }
        throw new RandoopBug("indexing error in ListOfLists");
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.lists" }, methods = { "iterator" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<E> toJDKList(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this) {
        List<E> result = new ArrayList<>();
        for (SimpleList<E> l : lists) {
            result.addAll(l.toJDKList());
        }
        return result;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "toJDKList" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.lists" }, methods = { "iterator" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ListOfLists<E> this) {
        return toJDKList().toString();
    }
}
