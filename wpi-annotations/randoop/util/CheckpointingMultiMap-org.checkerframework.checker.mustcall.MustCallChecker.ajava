package randoop.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A MultiMap that supports checkpointing and restoring to a checkpoint (that is, undoing all
 * operations up to a checkpoint, also called a "mark").
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.mustcall.MustCallChecker")
public class CheckpointingMultiMap<K, V> implements IMultiMap<K, V> {

    public static  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean verbose_log = false;

    private final @org.checkerframework.checker.mustcall.qual.MustCall({}) Map<K, Set<V>> map;

    public final @org.checkerframework.checker.mustcall.qual.MustCall({}) List<Integer> marks;

    private enum Ops {

        ADD, REMOVE
    }

    private final @org.checkerframework.checker.mustcall.qual.MustCall({}) List<OpKeyVal> ops;

    private  @org.checkerframework.checker.mustcall.qual.MustCall({}) int steps;

    // A triple of an operation, a key, and a value
    private class OpKeyVal {

        final @org.checkerframework.checker.mustcall.qual.MustCall({}) Ops op;

        final @org.checkerframework.checker.mustcall.qual.MustCall({}) K key;

        final @org.checkerframework.checker.mustcall.qual.MustCall({}) V val;

        OpKeyVal(final @org.checkerframework.checker.mustcall.qual.MustCall({}) Ops op, final K key, final V val) {
            this.op = op;
            this.key = key;
            this.val = val;
        }
    }

    public CheckpointingMultiMap() {
        map = new LinkedHashMap<>();
        marks = new ArrayList<>();
        ops = new ArrayList<>();
        steps = 0;
    }

    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean add(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, K key, V value) {
        if (verbose_log) {
            Log.logPrintf("ADD %s -> %s%n", key, value);
        }
        add_bare(key, value);
        ops.add(new OpKeyVal(Ops.ADD, key, value));
        steps++;
        return true;
    }

    private void add_bare(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException("args cannot be null.");
        }
        Set<V> values = map.computeIfAbsent(key, __ -> new LinkedHashSet<>(1));
        if (values.contains(value)) {
            throw new IllegalArgumentException("Mapping already present: " + key + " -> " + value);
        }
        values.add(value);
    }

    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean remove(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, K key, V value) {
        if (verbose_log) {
            Log.logPrintf("REMOVE %s -> %s%n", key, value);
        }
        remove_bare(key, value);
        ops.add(new OpKeyVal(Ops.REMOVE, key, value));
        steps++;
        return true;
    }

    private void remove_bare(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException("args cannot be null.");
        }
        Set<V> values = map.get(key);
        if (values == null) {
            throw new IllegalArgumentException("Mapping not present: " + key + " -> " + value);
        }
        values.remove(value);
        // If no more mapping from key, remove key from map.
        if (values.isEmpty()) {
            map.remove(key);
        }
    }

    /**
     * Checkpoint the state of the data structure, for use by {@link #undoToLastMark()}.
     */
    public void mark(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        marks.add(steps);
        steps = 0;
    }

    /**
     * Undo changes since the last call to {@link #mark()}.
     */
    public void undoToLastMark(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        if (marks.isEmpty()) {
            throw new IllegalArgumentException("No marks.");
        }
        Log.logPrintf("marks: %s%n", marks);
        for (int i = 0; i < steps; i++) {
            undoLastOp();
        }
        steps = marks.remove(marks.size() - 1);
    }

    private void undoLastOp(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        if (ops.isEmpty())
            throw new IllegalStateException("ops empty.");
        OpKeyVal last = ops.remove(ops.size() - 1);
        Ops op = last.op;
        K key = last.key;
        V val = last.val;
        if (op == Ops.ADD) {
            // Remove the mapping.
            Log.logPrintf("REMOVE %s%n", key + " ->" + val);
            remove_bare(key, val);
        } else if (op == Ops.REMOVE) {
            // Add the mapping.
            Log.logPrintf("ADD %s -> %s%n", key, val);
            add_bare(key, val);
        } else {
            // Really, we should never get here.
            throw new IllegalStateException("Unhandled op: " + op);
        }
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) Set<V> getValues(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, K key) {
        if (key == null)
            throw new IllegalArgumentException("arg cannot be null.");
        return map.getOrDefault(key, Collections.emptySet());
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean containsKey(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Object key) {
        if (key == null)
            throw new IllegalArgumentException("arg cannot be null.");
        return map.containsKey(key);
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) Set<K> keySet(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        return map.keySet();
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) int size(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        return map.size();
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) String toString(@org.checkerframework.checker.mustcall.qual.MustCall({}) CheckpointingMultiMap<K, V> this) {
        return map.toString();
    }
}
