package randoop.util;

import java.io.File;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.plumelib.util.DumpHeap;
import org.plumelib.util.StringsPlume;
import org.plumelib.util.SystemPlume;
import randoop.Globals;
import randoop.generation.AbstractGenerator;
import randoop.main.GenInputsAbstract;

/**
 * Modified from Daikon.FileIOProgress.
 */
// TODO: Split this class into two: one is responsible for
// displaying information at a regular interval, and a
// second class is responsible for monitoring for progress
// and terminating Randoop if it appears the tool is hanging.
// Currently this class does both things.
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class ProgressDisplay extends Thread {

    /**
     * Global lock to prevent interleaving of progress display messages.
     */
    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object print_synchro = new Object();

    /**
     * Give up after this many milliseconds, if the generator has not taken a step. That is, if it has
     * not attempted to generate a new test sequence.
     */
    private static  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int exit_if_no_steps_after_milliseconds = 10 * 1000;

    public enum Mode {

        SINGLE_LINE_OVERWRITE, MULTILINE, NO_DISPLAY
    }

    /**
     * The output mode.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Mode outputMode;

    /**
     * The test generator.
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setExecutionVisitor", "setTestCheckGenerator", "setTestPredicate" }) AbstractGenerator generator;

    /**
     * Creates a new ProgressDisplay.
     *
     * @param generator the test generator
     * @param outputMode the output mode
     */
    public ProgressDisplay(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "setExecutionVisitor", "setTestCheckGenerator", "setTestPredicate" }) AbstractGenerator generator, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Mode outputMode) {
        super("randoop.util.ProgressDisplay");
        if (generator == null) {
            throw new IllegalArgumentException("generator is null");
        }
        this.generator = generator;
        this.outputMode = outputMode;
        setDaemon(true);
    }

    /**
     * Return the progress message.
     *
     * @param withTime whether to include time and memory usage
     * @return the progress message
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String message(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean withTime) {
        return "Progress update: steps=" + generator.num_steps + ", test inputs generated=" + generator.num_sequences_generated + ", failing inputs=" + generator.num_failing_sequences + (withTime ? ("      (" + Instant.now() + "     " + StringsPlume.abbreviateNumber(SystemPlume.usedMemory(false)) + " used)") : "");
    }

    /**
     * Clients should set this variable instead of calling Thread.stop(), which is deprecated.
     * Typically a client calls "display()" before setting this.
     */
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shouldStop = false;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "clear", "noProgressOutput" })
    public void run(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        long progressInterval = GenInputsAbstract.progressintervalmillis;
        while (true) {
            if (shouldStop) {
                clear();
                return;
            }
            if (progressInterval > 0) {
                display(true);
            }
            // Do not enforce a global timeout if we are using threads:
            // if several test threads time out in a row, the global timeout
            // will be exceeded even though nothing is wrong.
            if (!ReflectionExecutor.usethreads) {
                // Check that we're still making progress.  If no new inputs are generated
                // for several seconds, we're probably in an infinite loop, and should exit.
                updateLastStepTime();
                long now = System.currentTimeMillis();
                if (now - lastStepTime > exit_if_no_steps_after_milliseconds) {
                    // TODO: The stack trace of this thread is not interesting.
                    // This should print the stack trace of the thread that is running a test.
                    exitDueToNoSteps();
                }
            }
            try {
                sleep(progressInterval > 0 ? progressInterval : 1000);
            } catch (InterruptedException e) {
                // If interrupted, just proceed.
            }
        }
    }

    /**
     * Exit due to too much time without taking a step.
     */
    // Ideally, on timeout we would terminate step() without shutting down the entire Randoop process.
    // That is not possible in general, unless the test is running in its own thread.
    // Thread.interrupt() just sets the thread's interrupt status.
    // So, tell the user to fix the problem or to run with --usethreads.
    private void exitDueToNoSteps(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        System.out.println();
        System.out.println();
        System.out.printf("*** Randoop has spent over %s seconds executing the following test.%n", exit_if_no_steps_after_milliseconds / 1000);
        System.out.println("See https://randoop.github.io/randoop/manual/index.html#no-input-generation .");
        System.out.println();
        System.out.println(AbstractGenerator.currSeq);
        System.out.println();
        System.out.println("Will dump a heap profile to randoop-slow.hprof.");
        File hprofFile = new File("randoop-slow.hprof");
        if (hprofFile.exists()) {
            hprofFile.delete();
        }
        DumpHeap.dumpHeap("randoop-slow.hprof");
        System.out.println("Will print all thread stack traces (twice) and exit with code 1.");
        System.out.println();
        printAllStackTraces();
        System.out.println();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            // If interrupted, just proceed.
        }
        printAllStackTraces();
        System.exit(1);
    }

    private void printAllStackTraces(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        for (Map.Entry<Thread, StackTraceElement[]> trace : Thread.getAllStackTraces().entrySet()) {
            System.out.println("--------------------------------------------------");
            System.out.println("Thread " + trace.getKey().toString());
            System.out.println("Stack trace:");
            StackTraceElement[] elts = trace.getValue();
            for (StackTraceElement elt : elts) {
                System.out.println(elt);
            }
        }
        System.out.println("--------------------------------------------------");
    }

    /**
     * When the most recent step completed.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long lastStepTime = System.currentTimeMillis();

    /**
     * The step number of the most recent step.
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long lastNumSteps = 0;

    /**
     * Set {@code lastStepTime} to when the most recent step completed.
     */
    private void updateLastStepTime(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        long seqs = generator.num_steps;
        if (seqs > lastNumSteps) {
            lastStepTime = System.currentTimeMillis();
            lastNumSteps = seqs;
        }
    }

    /**
     * Return true iff no progress output should be displayed.
     *
     * @return true iff no progress output should be displayed
     */
    @org.checkerframework.dataflow.qual.Pure
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean noProgressOutput(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        return GenInputsAbstract.progressintervalmillis <= 0 && GenInputsAbstract.progressintervalsteps <= 0;
    }

    /**
     * Clear the display; good to do before printing to System.out.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "noProgressOutput" })
    public void clear(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this) {
        if (noProgressOutput())
            return;
        // "display("");" is wrong because it leaves the timestamp and writes
        // spaces across the screen.
        // erase about 200 characters of text
        System.out.print("\r" + StringsPlume.rpad("", 199));
        // return to beginning of line
        System.out.print("\r");
        System.out.flush();
    }

    /**
     * Displays the current status. Call this if you don't want to wait until the next automatic
     * display.
     *
     * @param withTime whether to print time and memory usage
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "noProgressOutput" })
    public void display(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean withTime) {
        if (noProgressOutput())
            return;
        display(message(withTime));
    }

    /**
     * Displays the given message.
     *
     * @param message the message to display
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "noProgressOutput" })
    private void display(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ProgressDisplay this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String message) {
        if (noProgressOutput())
            return;
        synchronized (print_synchro) {
            System.out.print((this.outputMode == Mode.SINGLE_LINE_OVERWRITE ? "\r" : Globals.lineSep) + message);
            System.out.flush();
        }
        // System.out.println (status);
        // Log.logPrintf("Free memory: %s%n", Runtime.getRuntime().freeMemory());
        // Log.logPrintf("Used memory: %s%n",
        //    Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));
    }
}
