package randoop.util;

import org.plumelib.util.StringsPlume;

/**
 * Wraps a method or constructor together with its arguments. Can be run only once. {@link
 * #hasRun()} indicates whether it has been run.
 *
 * <p>Implemented by parts of Randoop that want to execute reflection code via ReflectionExecutor.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public abstract class ReflectionCode {

    /**
     * Has this started execution?
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasStarted;

    /**
     * Has this been executed already?
     */
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasRun;

    // Before runReflectionCodeRaw is executed, both of these fields are null. After
    // runReflectionCodeRaw is executed, if exceptionThrown is null, then retval is the returned value
    // (which might be null).
    /**
     * The value yielded by execution.
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object retval;

    /**
     * The exception thrown by execution.
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Throwable exceptionThrown;

    @org.checkerframework.dataflow.qual.Pure
    public final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasStarted(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) {
        return hasStarted;
    }

    @org.checkerframework.dataflow.qual.Pure
    public final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasRun(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) {
        return hasRun;
    }

    protected final void setHasStarted(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) {
        if (hasStarted) {
            throw new ReflectionCodeException("cannot run this twice");
        }
        hasStarted = true;
    }

    protected final void setHasRun(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "runReflectionCodeRaw", "setHasStarted" }) ReflectionCode this) {
        if (hasRun) {
            throw new ReflectionCodeException("cannot run this twice");
        }
        hasRun = true;
    }

    /**
     * Runs the reflection code that this object represents.
     *
     * <ol>
     *   <li>This method calls {@link #runReflectionCodeRaw()} to perform the actual work. {@link
     *       #runReflectionCodeRaw()} sets the {@code retVal} or {@code exceptionThrown} field, or
     *       throws an exception if there is a bug in Randoop.
     * </ol>
     *
     * @throws ReflectionCodeException if execution results in conflicting error and success states;
     *     this results from a bug in Randoop
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "runReflectionCodeRaw", "setHasRun", "setHasStarted" })
    public final void runReflectionCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) throws ReflectionCodeException {
        this.setHasStarted();
        runReflectionCodeRaw();
        this.setHasRun();
    }

    /**
     * Execute the reflection code. All Randoop implementation errors must be thrown as
     * ReflectionCodeException because everything else is caught.
     *
     * @throws ReflectionCodeException if execution results in conflicting error and success states;
     *     this results from a bug in Randoop
     */
    @org.checkerframework.dataflow.qual.Pure
    protected abstract void runReflectionCodeRaw(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) throws ReflectionCodeException;

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "hasRun" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object getReturnValue(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getExceptionThrown", "hasRun" }) ReflectionCode this) {
        if (!hasRun()) {
            throw new IllegalStateException("run first, then ask");
        }
        return retval;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "hasRun" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Throwable getExceptionThrown(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) {
        if (!hasRun()) {
            throw new IllegalStateException("run first, then ask");
        }
        return exceptionThrown;
    }

    /**
     * A suffix to be called by toString().
     *
     * @return the status of the command
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "hasStarted" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String status(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionCode this) {
        if (!hasStarted() && !hasRun()) {
            return " not run yet";
        } else if (hasStarted() && !hasRun()) {
            return " failed to run";
        } else if (!hasStarted() && hasRun()) {
            return " ILLEGAL STATE";
        } else if (exceptionThrown == null) {
            return " returned: " + StringsPlume.toStringAndClass(retval);
        } else {
            return " threw: " + exceptionThrown;
        }
    }

    /**
     * Indicates a bug in the ReflectionCode class.
     */
    static final class ReflectionCodeException extends IllegalStateException {

        private static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) long serialVersionUID = -7508201027241079866L;

        @org.checkerframework.dataflow.qual.SideEffectFree
        ReflectionCodeException(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String msg) {
            super(msg);
        }

        @org.checkerframework.dataflow.qual.SideEffectFree
        ReflectionCodeException(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String msg, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Throwable cause) {
            super(msg, cause);
        }

        @org.checkerframework.dataflow.qual.SideEffectFree
        ReflectionCodeException(Throwable cause) {
            super(cause);
        }
    }
}
