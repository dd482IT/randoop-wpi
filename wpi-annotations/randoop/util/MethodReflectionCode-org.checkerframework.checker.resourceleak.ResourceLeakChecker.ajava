package randoop.util;

import static randoop.Globals.lineSep;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;

/**
 * Wraps a method together with its arguments, ready for execution. Can be run only once.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public final class MethodReflectionCode extends ReflectionCode {

    /**
     * The method to be called.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getGenericParameterTypes" }) Method method;

    /**
     * The receiver, or null for a static method.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object receiver;

    /**
     * The arguments that the method is applied to.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] inputs;

    /**
     * Create a new MethodReflectionCode to represent a method invocation.
     *
     * @param method the method to be called
     * @param receiver the receiver, or null for a static method
     * @param inputs the arguments that the method is applied to
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.method" }, methods = { "getGenericParameterTypes", "isAccessible" })
    public MethodReflectionCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getGenericParameterTypes" }) Method method, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object receiver, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] inputs) {
        this.receiver = receiver;
        this.method = method;
        this.inputs = inputs;
        if (!this.method.isAccessible()) {
            this.method.setAccessible(true);
            Log.logPrintf("not accessible: %s%n", this.method);
            // TODO something is bizarre - it seems that a public method can be
            // not-accessible sometimes. RatNum(int,int)
            // TODO you cannot just throw the exception below - because no sequences
            // will be created in the randoop.experiments.
            // throw new IllegalStateException("Not accessible: " + this.meth);
        }
    }

    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "this.receiver" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.method" }, methods = { "getGenericParameterTypes", "getModifiers" })
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.receiver" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    private  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isInstanceMethod(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MethodReflectionCode this) {
        return !Modifier.isStatic(method.getModifiers());
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.method" }, methods = { "getGenericParameterTypes", "invoke" })
    public void runReflectionCodeRaw(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MethodReflectionCode this) {
        Log.logPrintf("runReflectionCodeRaw: %s%n", method);
        try {
            this.retval = this.method.invoke(this.receiver, this.inputs);
            try {
                Log.logPrintf("runReflectionCodeRaw(%s) => %s%n", method, status());
            } catch (OutOfMemoryError e) {
                Log.logPrintf("runReflectionCodeRaw(%s) => OutOfMemoryError, %s%n", method, status());
            }
            if (receiver == null && isInstanceMethod()) {
                throw new ReflectionCodeException("receiver was null - expected NPE from call to: " + method);
            }
        } catch (NullPointerException e) {
            this.exceptionThrown = e;
        } catch (InvocationTargetException e) {
            // The underlying method threw an exception
            this.exceptionThrown = e.getCause();
        } catch (Throwable e) {
            // Any other exception indicates Randoop should not have called the method
            String message = String.format("error invoking %s on %d arguments:", method, (receiver == null ? 0 : 1) + inputs.length);
            if (receiver != null) {
                message += lineSep + "  " + receiver;
            }
            for (Object input : inputs) {
                message += lineSep + "  " + input;
            }
            throw new ReflectionCodeException(message, e);
        }
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "hasStarted", "status" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MethodReflectionCode this) {
        return "Call to " + method + " receiver: " + receiver + " args: " + Arrays.toString(inputs) + status();
    }
}
