package randoop.util;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

/**
 * A Set that supports settingcheckpoints (also called "marks") and restoring the data structure's
 * state to them.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
public class CheckpointingSet<E> implements Set<E> {

    // This uses a MultiMap just because that is an existing checkpointing data structure.
    // The value is always true in this mapping, never false.
    public final CheckpointingMultiMap<E, Boolean> map;

    public CheckpointingSet() {
        this.map = new CheckpointingMultiMap<>();
    }

    public boolean add(E elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        if (contains(elt))
            throw new IllegalArgumentException("set already contains elt " + elt);
        return map.add(elt, Boolean.TRUE);
    }

    public boolean contains(Object elt) {
        if (elt == null)
            throw new IllegalArgumentException("arg cannot be null.");
        return map.containsKey(elt);
    }

    public boolean remove(Object elt) {
        if (elt == null) {
            throw new IllegalArgumentException("arg cannot be null.");
        }
        E eltCasted = (E) elt;
        return map.remove(eltCasted, Boolean.TRUE);
    }

    public int size() {
        return map.size();
    }

    /**
     * Checkpoint the state of the data structure, for use by {@link #undoToLastMark()}.
     */
    public void mark(@org.checkerframework.checker.signature.qual.SignatureUnknown CheckpointingSet<E> this) {
        map.mark();
    }

    /**
     * Undo changes since the last call to {@link #mark()}.
     */
    public void undoToLastMark(@org.checkerframework.checker.signature.qual.SignatureUnknown CheckpointingSet<E> this) {
        map.undoToLastMark();
    }

    public String toString() {
        return map.keySet().toString();
    }

    public void clear() {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public boolean addAll(Collection<? extends E> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public boolean containsAll(Collection<?> c) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public <T> T[] toArray(T[] a) {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public Object[] toArray() {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public Iterator<E> iterator() {
        throw new UnsupportedOperationException("not yet implemented");
    }

    public boolean isEmpty() {
        // return map.isEmpty();
        throw new UnsupportedOperationException("not yet implemented");
    }
}
