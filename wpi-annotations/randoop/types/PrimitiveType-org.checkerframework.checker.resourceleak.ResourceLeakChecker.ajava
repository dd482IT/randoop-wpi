package randoop.types;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents a Java primitive type. Corresponds to primitive types as defined in JLS <a
 * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-PrimitiveType">section
 * 4.2</a>.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class PrimitiveType extends Type {

    /**
     * The runtime class of the primitive type.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> runtimeClass;

    /**
     * All the PrimitiveTypes that have been created.
     */
    private static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Map<Class<?>, PrimitiveType> cache = new HashMap<>();

    /**
     * Creates a primitive type from the given runtime class.
     *
     * @param runtimeClass the runtime class
     * @return the PrimitiveType for the given runtime class
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "randoop.types.PrimitiveType.cache" }, methods = { "computeIfAbsent" })
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType forClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> runtimeClass) {
        return cache.computeIfAbsent(runtimeClass, PrimitiveType::new);
    }

    /**
     * Creates a primitive type from the given runtime class.
     *
     * @param runtimeClass the runtime class
     */
    private PrimitiveType(Class<?> runtimeClass) {
        assert runtimeClass.isPrimitive() : "must be initialized with primitive type, got " + runtimeClass.getName();
        assert !runtimeClass.equals(void.class) : "void should be represented by VoidType";
        this.runtimeClass = runtimeClass;
    }

    /**
     * {@inheritDoc}
     *
     * @return true if the runtime class of this primitive type and the object are the same, false
     *     otherwise
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof PrimitiveType)) {
            return false;
        }
        PrimitiveType t = (PrimitiveType) obj;
        return this.runtimeClass.equals(t.runtimeClass);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.runtimeClass" }, methods = { "hashCode" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return runtimeClass.hashCode();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.runtimeClass" }, methods = { "getCanonicalName" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getFqName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return runtimeClass.getCanonicalName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.runtimeClass" }, methods = { "getCanonicalName" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getBinaryName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return runtimeClass.getCanonicalName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.runtimeClass" }, methods = { "getSimpleName" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getSimpleName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return runtimeClass.getSimpleName();
    }

    /**
     * {@inheritDoc}
     *
     * @return the {@code Class} object for this primitive type
     */
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> getRuntimeClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return runtimeClass;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Checks for <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html#jls-5.1.2">primitive
     * widening (section 5.1.2)</a>, and <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html#jls-5.1.8">unboxing
     * (section 5.1.8)</a> conversions. For a primitive type, returns true if this type can be
     * assigned from the source type by primitive widening or unboxing.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "equals", "isVoid" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "equals", "isAssignableFrom" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isAssignableFrom(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type sourceType) {
        if (super.isAssignableFrom(sourceType)) {
            return true;
        }
        // test for primitive widening or unboxing conversion
        if (sourceType.isPrimitive()) {
            // primitive widening conversion
            return PrimitiveTypes.isAssignable(this.runtimeClass, sourceType.getRuntimeClass());
        }
        if (sourceType.isBoxedPrimitive()) {
            // unbox then primitive widening conversion
            PrimitiveType primitiveSourceType = ((NonParameterizedType) sourceType).toPrimitive();
            return this.isAssignableFrom(primitiveSourceType);
        }
        return false;
    }

    /**
     * {@inheritDoc}
     *
     * @return true since this object represents a primitive type
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isPrimitive(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * @return true since this object represents a non-receiver type
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isNonreceiverType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this) {
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Specifically implements tests for primitive types as defined in <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.10.1">section 4.10.1
     * of JLS for JavaSE 8</a>.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "isPrimitive" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isSubtypeOf(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrimitiveType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type otherType) {
        return otherType.isPrimitive() && PrimitiveTypes.isSubtype(this.getRuntimeClass(), otherType.getRuntimeClass());
    }

    /**
     * Returns the boxed type for this primitive type.
     *
     * @return the boxed type for this primitive type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) NonParameterizedType toBoxedPrimitive(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "equals", "isPrimitive", "isVoid" }) PrimitiveType this) {
        return NonParameterizedType.forClass(PrimitiveTypes.toBoxedType(this.getRuntimeClass()));
    }
}
