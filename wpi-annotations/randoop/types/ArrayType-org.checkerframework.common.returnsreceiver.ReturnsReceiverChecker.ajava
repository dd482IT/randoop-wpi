package randoop.types;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Represents an array type as defined in JLS, Section 4.3.
 *
 * <pre>
 *   ArrayType:
 *     PrimitiveType [ ] { [ ] }
 *     ClassOrInterfaceType [ ] { [ ] }
 *     TypeVariable [ ] { [ ] }
 * </pre>
 *
 * The type preceding the rightmost set of brackets is the <i>component</i> type, while the type
 * preceding the brackets is the <i>element</i> type. An array may have components of any type.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker")
public class ArrayType extends ReferenceType {

    /**
     * The type of components in this array.
     */
    private final  Type componentType;

    /**
     * The runtime type for this array.
     */
    private final  Class<?> runtimeClass;

    /**
     * Creates an {@code ArrayType} with the given component type and runtime class.
     *
     * @param componentType the component type
     * @param runtimeClass the runtime class
     */
    private ArrayType( Type componentType,  Class<?> runtimeClass) {
        this.componentType = componentType;
        this.runtimeClass = runtimeClass;
    }

    /**
     * Creates an array type for the given {@code java.lang.reflect.Class} object.
     *
     * @param arrayClass the {@code Class} object for array type
     * @return the {@code ArrayType} for the given class object
     */
    public static  ArrayType forClass( Class<?> arrayClass) {
        if (!arrayClass.isArray()) {
            throw new IllegalArgumentException("type must be an array");
        }
        Type componentType = Type.forClass(arrayClass.getComponentType());
        return new ArrayType(componentType, arrayClass);
    }

    /**
     * Creates an {@code ArrayType} from a {@code java.lang.reflect.Type} reference. First checks
     * whether reference has type {@code java.lang.reflectGenericArrayType}, and if so performs the
     * conversion. If the reference is to a {@code Class} object, then delegates to {@link
     * #forClass(Class)}.
     *
     * @param type the {@link java.lang.reflect.Type} reference
     * @return the {@code Type} for the array type
     */
    public static  ArrayType forType(java.lang.reflect. Type type) {
        if (type instanceof java.lang.reflect.GenericArrayType) {
            java.lang.reflect.GenericArrayType arrayType = (java.lang.reflect.GenericArrayType) type;
            Type componentType = Type.forType(arrayType.getGenericComponentType());
            return ArrayType.ofComponentType(componentType);
        }
        if ((type instanceof Class<?>) && ((Class<?>) type).isArray()) {
            Type componentType = Type.forType(((Class<?>) type).getComponentType());
            return ArrayType.ofComponentType(componentType);
        }
        throw new IllegalArgumentException("type " + type + " must be an array type");
    }

    /**
     * Creates an {@code ArrayType} for the given component type. If the component type is a type
     * variable then creates a type with an {@link Object} array as the rawtype.
     *
     * @param componentType the component type
     * @return an {@code ArrayType} with the given component type
     */
    public static  ArrayType ofComponentType( Type componentType) {
        if (componentType instanceof TypeVariable) {
            return new ArrayType(componentType, Array.newInstance(Object.class, 0).getClass());
        }
        return new ArrayType(componentType, Array.newInstance(componentType.getRuntimeClass(), 0).getClass());
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean equals( ArrayType this,  Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof ArrayType)) {
            return false;
        }
        ArrayType t = (ArrayType) obj;
        return componentType.equals(t.componentType) && runtimeClass.equals(t.runtimeClass);
    }

    @org.checkerframework.dataflow.qual.Pure
    public   int hashCode( ArrayType this) {
        return Objects.hash(componentType, runtimeClass);
    }

    public  ArrayType substitute( ArrayType this,  Substitution substitution) {
        Type type = componentType.substitute(substitution);
        if (!type.equals(this)) {
            return ArrayType.ofComponentType(type);
        } else {
            return this;
        }
    }

    /**
     * Returns the component type of this array type.
     *
     * @return the component type of this array type
     */
    @org.checkerframework.dataflow.qual.Pure
    public  Type getComponentType( ArrayType this) {
        return componentType;
    }

    /**
     * Returns the element type of this array type. If the component type of this array type is not an
     * array type, the element type is the component type. Otherwise, the element type is the element
     * type of the component type.
     *
     * @return the element type of this array type
     */
    public  Type getElementType( ArrayType this) {
        if (componentType.isArray()) {
            return ((ArrayType) componentType).getElementType();
        }
        return componentType;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  String getFqName( ArrayType this) {
        return componentType.getFqName() + "[]";
    }

    @org.checkerframework.dataflow.qual.Pure
    public  String getBinaryName( ArrayType this) {
        return componentType.getBinaryName() + "[]";
    }

    @org.checkerframework.dataflow.qual.Pure
    public  String getSimpleName( ArrayType this) {
        return componentType.getSimpleName() + "[]";
    }

    @org.checkerframework.dataflow.qual.Pure
    public  Class<?> getRuntimeClass( ArrayType this) {
        return runtimeClass;
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public  List<TypeVariable> getTypeParameters( ArrayType this) {
        if (componentType.isReferenceType()) {
            return ((ReferenceType) componentType).getTypeParameters();
        } else {
            // There are usually few type parameters.
            return new ArrayList<>(2);
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean isArray( ArrayType this) {
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * <p>For an array type, check for assignability by reference widening. If not otherwise
     * assignable, check for unchecked conversion, which occurs when this type is {@code
     * C<T1,...,Tk>[]} and other type is {@code C[]} (e.g., the component type is the rawtype {@code
     * C}).
     */
    @org.checkerframework.dataflow.qual.Pure
    public   boolean isAssignableFrom( ArrayType this,  Type otherType) {
        if (super.isAssignableFrom(otherType)) {
            return true;
        }
        if (otherType.isArray() && this.componentType.isParameterized()) {
            Type otherElementType = ((ArrayType) otherType).componentType;
            return otherElementType.isRawtype() && otherElementType.runtimeClassIs(this.componentType.getRuntimeClass());
        }
        return false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean isGeneric( ArrayType this,   boolean ignoreWildcards) {
        return componentType.isGeneric(ignoreWildcards);
    }

    /**
     * {@inheritDoc}
     *
     * <p>This method specifically uses the definition in <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.10.3">section 4.10.2
     * of JLS for JavaSE 8</a>.
     */
    @org.checkerframework.dataflow.qual.Pure
    public   boolean isSubtypeOf( ArrayType this,  Type otherType) {
        if (super.isSubtypeOf(otherType)) {
            return true;
        }
        if (otherType.equals(JavaTypes.CLONEABLE_TYPE)) {
            return true;
        }
        if (otherType.equals(JavaTypes.SERIALIZABLE_TYPE)) {
            return true;
        }
        if (otherType.isArray() && componentType.isReferenceType()) {
            ArrayType otherArrayType = (ArrayType) otherType;
            return otherArrayType.componentType.isReferenceType() && this.componentType.isSubtypeOf(otherArrayType.componentType);
        }
        return false;
    }

    public  Type getRawtype( ArrayType this) {
        if (!componentType.isGeneric()) {
            return this;
        }
        return new ArrayType(componentType.getRawtype(), runtimeClass);
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean hasWildcard( ArrayType this) {
        return componentType.hasWildcard();
    }

    @org.checkerframework.dataflow.qual.Pure
    public   boolean hasCaptureVariable( ArrayType this) {
        return componentType.hasCaptureVariable();
    }

    /**
     * Indicates whether this array type has a parameterized element type.
     *
     * @return true if the element type is parameterized; false otherwise
     */
    public   boolean hasParameterizedElementType( ArrayType this) {
        return getElementType().isParameterized();
    }

    /**
     * Returns the non-parameterized form for this array type. For instance, converts {@code
     * List<String>[]} to {@code List[]}, {@code List<String>[][]} to {@code List[][]}, and {@code
     * int[]} to {@code int[]}.
     *
     * @return the non-parameterized form of this array type
     */
    public  ArrayType getRawTypeArray( ArrayType this) {
        Type rawElementType;
        if (this.componentType.isArray()) {
            rawElementType = ((ArrayType) componentType).getRawTypeArray();
        } else if (this.componentType.isClassOrInterfaceType()) {
            rawElementType = ((ClassOrInterfaceType) componentType).getRawtype();
        } else {
            return this;
        }
        return ArrayType.ofComponentType(rawElementType);
    }

    public   int getDimensions( ArrayType this) {
        int dimensions = 1;
        if (componentType.isArray()) {
            dimensions += ((ArrayType) componentType).getDimensions();
        }
        return dimensions;
    }
}
