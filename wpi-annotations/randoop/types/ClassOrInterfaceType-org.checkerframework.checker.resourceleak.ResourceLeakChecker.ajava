package randoop.types;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import org.plumelib.util.StringsPlume;

/**
 * Represents a class or interface type as defined in JLS Section 4.3.
 *
 * <p>This abstract class corresponds to this grammar production in the JLS:
 *
 * <pre>
 *   ClassOrInterfaceType:
 *     ClassType
 *     InterfaceType
 * </pre>
 *
 * InterfaceType is syntactically the same as ClassType. Therefore, {@code ClassType} and {@code
 * InterfaceType} do not exist as subclasses of this class, Rather, the subclasses of this type
 * distinguish between types with parameters ({@link ParameterizedType}), and types without ({@link
 * NonParameterizedType}).
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public abstract class ClassOrInterfaceType extends ReferenceType {

    /**
     * Set to true to enable debug output to standard out.
     */
    private static  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean debug = false;

    /**
     * The enclosing type. Non-null only if this is a nested type (either a member type or a nested
     * static type).
     */
    protected @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType enclosingType = null;

    /**
     * Translates a {@code Class} object that represents a class or interface into a {@code
     * ClassOrInterfaceType} object. If the object has parameters, then delegates to {@link
     * ParameterizedType#forClass(Class)}. Otherwise, creates a {@link NonParameterizedType} object
     * from the given object.
     *
     * @param classType the class type to translate
     * @return the {@code ClassOrInterfaceType} object created from the given class type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getEnclosingClass", "getTypeParameters", "isArray", "isPrimitive" })
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType forClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> classType) {
        if (classType.isArray() || classType.isPrimitive()) {
            throw new IllegalArgumentException("type must be a class or interface, got " + classType);
        }
        ClassOrInterfaceType type;
        if (classType.getTypeParameters().length > 0) {
            type = ParameterizedType.forClass(classType);
        } else {
            type = NonParameterizedType.forClass(classType);
        }
        Class<?> enclosingClass = classType.getEnclosingClass();
        if (enclosingClass != null) {
            type.setEnclosingType(ClassOrInterfaceType.forClass(enclosingClass));
        }
        return type;
    }

    /**
     * Creates a {@code ClassOrInterfaceType} object for a given {@code java.lang.reflect.Type}
     * reference. If type is a {@code java.lang.reflect.ParameterizedType}, then calls {@link
     * ParameterizedType#forType(java.lang.reflect.Type)}. Otherwise, if type is a {@code Class}
     * object, calls {@link #forClass(Class)}.
     *
     * @param type the type reference
     * @return the {@code ClassOrInterfaceType} object for the given type
     */
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType forType(java.lang.reflect.@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type type) {
        if (type instanceof java.lang.reflect.ParameterizedType) {
            java.lang.reflect.ParameterizedType t = (java.lang.reflect.ParameterizedType) type;
            // non-generic member classes of a generic class show up as ParameterizedType
            // treat these as Class<?>
            Class<?> rawType = (Class<?>) t.getRawType();
            if (rawType.getTypeParameters().length == 0) {
                return ClassOrInterfaceType.forClass(rawType);
            }
            return ParameterizedType.forType(t);
        }
        if (type instanceof Class<?>) {
            Class<?> classType = (Class<?>) type;
            // if the type is generic, forcing the type to be a parameterized type can result in errors
            // because type parameters will be from the class declaration rather than the context of
            // the type in the code.  In this case, it is possible to have two distinct
            // java.lang.reflect.TypeVariables that represent the same type parameter.
            //
            return new NonParameterizedType(classType);
        }
        throw new IllegalArgumentException("Unable to create class type from type " + type);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isNestedClass" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof ClassOrInterfaceType)) {
            return false;
        }
        ClassOrInterfaceType otherType = (ClassOrInterfaceType) obj;
        return !(this.isNestedClass() && otherType.isNestedClass()) || this.enclosingType.equals(otherType.enclosingType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return Objects.hash(enclosingType);
    }

    /**
     * {@inheritDoc}
     *
     * <p>This abstract method allows substitutions to be applied to {@link ClassOrInterfaceType}
     * objects without casting.
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType substitute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution);

    /**
     * Applies the substitution to the enclosing type of this type and adds the result as the
     * enclosing class of the given type.
     *
     * @param substitution the substitution to apply to the enclosing type
     * @param type the type to which resulting enclosing type is to be added; will be side-effected
     * @return the type with enclosing type added if needed
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass" })
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType substitute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType type) {
        if (this.isMemberClass()) {
            type.setEnclosingType(enclosingType.substitute(substitution));
        }
        return type;
    }

    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType applyCaptureConversion(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this);

    /**
     * Applies capture conversion to the enclosing type of this type and adds the result as the
     * enclosing class of the given type.
     *
     * @param type this type with capture conversion applied; will be side-effected
     * @return the type with converted enclosing type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass" })
    final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType applyCaptureConversion(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType type) {
        if (this.isMemberClass()) {
            type.setEnclosingType(enclosingType.applyCaptureConversion());
        }
        return type;
    }

    /**
     * Returns the name of this class type. Does not include package, enclosing classes, or type
     * arguments.
     *
     * @return the name of this class
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getSimpleName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return getRuntimeClass().getSimpleName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getCanonicalName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return getRuntimeClass().getCanonicalName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass", "isNestedClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getFqName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        if (this.isNestedClass()) {
            if (this.isStatic()) {
                return enclosingType.getCanonicalName() + "." + this.getSimpleName();
            }
            return enclosingType.getFqName() + "." + this.getSimpleName();
        }
        return this.getCanonicalName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass", "isNestedClass" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getBinaryName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        if (this.isNestedClass()) {
            if (this.isStatic()) {
                // HACK
                return enclosingType.getBinaryName().replaceAll("<[^<]*>$", "") + "$" + this.getSimpleName();
            }
            return enclosingType.getBinaryName() + "$" + this.getSimpleName();
        }
        return getRuntimeClass().getName();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass", "getSimpleName", "isNestedClass" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getUnqualifiedBinaryName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        String prefix = "";
        if (this.isNestedClass()) {
            prefix = enclosingType.getUnqualifiedBinaryName() + "$";
        }
        return prefix + this.getSimpleName();
    }

    /**
     * Returns the interface types directly implemented by this class or interface type. Preserves the
     * order in the reflection method {@link Class#getGenericInterfaces()}. If no interfaces are
     * implemented, then returns the empty list.
     *
     * @return the list of interfaces directly implemented by this type
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<ClassOrInterfaceType> getInterfaces(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this);

    /**
     * Returns the package of the runtime class of this type.
     *
     * @return the package of the runtime class of this type, or null if there is none
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getRuntimeClass" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Package getPackage(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        Class<?> c = getRuntimeClass();
        if (c == null) {
            throw new IllegalArgumentException("Class " + this.toString() + " has no runtime class");
        }
        return c.getPackage();
    }

    /**
     * Return the package part of a type name, including the final period. Returns the empty string
     * for a type in the unnamed package.
     *
     * @return the package part of a type name, or ""
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getPackage", "getRuntimeClass" })
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getPackagePrefix() {
        Package pkg = getPackage();
        if (pkg == null) {
            return "";
        } else {
            return pkg.getName() + ".";
        }
    }

    /**
     * Returns the non-parameterized form of this class type.
     *
     * @return the non-parameterized form of this class type
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) NonParameterizedType getRawtype(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this);

    /**
     * Finds the parameterized type that is a supertype of this class that also matches the given
     * generic class. For example, if {@code class C<T> implements Comparator<T>} and {@code class A
     * extends C<String>}, then when applied to {@code A}, this method would return {@code C<String>}
     * when given {@code C<T>}, and {@code Comparator<String>} when given {@code Comparator<E>}.
     * Returns null if there is no such type.
     *
     * <p>Performs a depth-first search of the supertype relation for this type. If the goal type is
     * an interface, then searches the interfaces of this type first.
     *
     * @param goalType the generic class type
     * @return the instantiated type matching the goal type, or null
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "isInterface" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getInterfaces" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InstantiatedType getMatchingSupertype(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType goalType) {
        if (goalType.isInterface()) {
            for (ClassOrInterfaceType interfaceType : this.getInterfaces()) {
                if (goalType.getRuntimeClass().isAssignableFrom(interfaceType.getRuntimeClass())) {
                    if (interfaceType.isParameterized()) {
                        InstantiatedType type = (InstantiatedType) interfaceType;
                        if (type.isInstantiationOf(goalType)) {
                            return (InstantiatedType) interfaceType;
                        }
                        InstantiatedType result = type.getMatchingSupertype(goalType);
                        if (result != null) {
                            return result;
                        }
                    } else {
                        return interfaceType.getMatchingSupertype(goalType);
                    }
                }
            }
        }
        ClassOrInterfaceType superclass = this.getSuperclass();
        if (superclass != null && !superclass.isObject() && goalType.getRuntimeClass().isAssignableFrom(superclass.getRuntimeClass())) {
            if (superclass.isInstantiationOf(goalType)) {
                return (InstantiatedType) superclass;
            }
            return superclass.getMatchingSupertype(goalType);
        }
        return null;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "equals" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution getInstantiatingSubstitution(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReferenceType goalType) {
        Substitution superResult = ReferenceType.getInstantiatingSubstitutionforTypeVariable(this, goalType);
        if (superResult != null) {
            return superResult;
        }
        assert goalType.isGeneric() : "goal type must be generic";
        Substitution substitution = new Substitution();
        if (this.isMemberClass()) {
            substitution = enclosingType.getInstantiatingSubstitution(goalType);
            if (substitution == null) {
                return null;
            }
        }
        if (goalType instanceof GenericClassType) {
            InstantiatedType supertype = this.getMatchingSupertype((GenericClassType) goalType);
            if (supertype != null) {
                Substitution supertypeSubstitution = supertype.getTypeSubstitution();
                if (supertypeSubstitution == null) {
                    return null;
                }
                substitution = substitution.extend(supertypeSubstitution);
            }
        }
        return substitution;
    }

    /**
     * Return the type for the superclass for this class.
     *
     * @return superclass of this type, or the {@code Object} type if this type has no superclass
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType getSuperclass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this);

    /**
     * Return the set of all of the supertypes of this type.
     *
     * @return the set of all supertypes of this type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "equals", "isObject" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<ClassOrInterfaceType> getSuperTypes(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isClassOrInterfaceType" }) ClassOrInterfaceType this) {
        Collection<ClassOrInterfaceType> supertypes = new ArrayList<>();
        if (this.isObject()) {
            return supertypes;
        }
        ClassOrInterfaceType superclass = this.getSuperclass();
        if (superclass != null) {
            supertypes.add(superclass);
            supertypes.addAll(superclass.getSuperTypes());
        }
        for (ClassOrInterfaceType interfaceType : this.getInterfaces()) {
            supertypes.add(interfaceType);
            supertypes.addAll(interfaceType.getSuperTypes());
        }
        return supertypes;
    }

    /**
     * Return the immediate supertypes of this type.
     *
     * @return the immediate supertypes of this type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "equals", "isObject" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<ClassOrInterfaceType> getImmediateSupertypes(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        if (this.isObject()) {
            return Collections.emptyList();
        }
        ClassOrInterfaceType superclass = this.getSuperclass();
        List<ClassOrInterfaceType> interfaces = this.getInterfaces();
        List<ClassOrInterfaceType> supertypes = new ArrayList<>(interfaces.size() + 1);
        supertypes.add(superclass);
        supertypes.addAll(interfaces);
        return supertypes;
    }

    /**
     * Return all supertypes of this type, including itself.
     *
     * @return all supertypes of this type, including itself
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Collection<ClassOrInterfaceType> getAllSupertypesInclusive(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        LinkedHashSet<ClassOrInterfaceType> result = new LinkedHashSet<>();
        Queue<ClassOrInterfaceType> worklist = new ArrayDeque<>();
        worklist.add(this);
        while (!worklist.isEmpty()) {
            ClassOrInterfaceType type = worklist.remove();
            if (result.add(type)) {
                // result did not already contain the element
                worklist.addAll(type.getImmediateSupertypes());
            }
        }
        return result;
    }

    /**
     * Indicate whether this class is abstract.
     *
     * @return true if this class is abstract, false otherwise
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isAbstract();

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isGeneric(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean ignoreWildcards) {
        return this.isMemberClass() && enclosingType.isGeneric(ignoreWildcards);
    }

    /**
     * {@inheritDoc}
     *
     * <p>For a {@link ClassOrInterfaceType} that is a member class, if {@code otherType} is also a
     * member class, then the enclosing type of this type must instantiate the enclosing type of
     * {@code otherType}.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "equals", "isInstantiationOf" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isInstantiationOf(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReferenceType otherType) {
        if (super.isInstantiationOf(otherType)) {
            return true;
        }
        if (this.isNestedClass() && (otherType instanceof ClassOrInterfaceType)) {
            ClassOrInterfaceType otherClassType = (ClassOrInterfaceType) otherType;
            // TODO: This checks that both are member classes, but they should be named the same and with
            // the same type parameters too.
            return otherClassType.isNestedClass() && this.enclosingType.isInstantiationOf(otherClassType.enclosingType);
        }
        return false;
    }

    /**
     * Indicate whether this class is a nested class.
     *
     * @return true iff this class is a nested class
     */
    @org.checkerframework.dataflow.qual.Pure
    public final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isNestedClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return enclosingType != null;
    }

    /**
     * Indicate whether this class is a member of another class. (see <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.5">JLS section
     * 8.5</a>).
     *
     * @return true if this class is a member class, false otherwise
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isNestedClass" })
    @org.checkerframework.dataflow.qual.Pure
    public final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isMemberClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return isNestedClass() && !isStatic();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isParameterized(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return this.isMemberClass() && enclosingType.isParameterized();
    }

    /**
     * Indicates whether this class is static.
     *
     * @return true if this class is static, false otherwise
     */
    @org.checkerframework.dataflow.qual.Pure
    public abstract  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isStatic(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this);

    /**
     * Test whether this type is a subtype of the given type according to transitive closure of
     * definition of the <i>direct supertype</i> relation in <a
     * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.10.2">section 4.10.2
     * of JLS for JavaSE 8</a>.
     *
     * @param otherType the possible supertype
     * @return true if this type is a subtype of the given type, false otherwise
     * @see #isAssignableFrom(Type)
     * @see ParameterizedType#isSubtypeOf(Type)
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "equals", "isObject" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getClass" })
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isSubtypeOf(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type otherType) {
        if (debug) {
            System.out.printf("isSubtypeOf(%s, %s) [%s, %s]%n", this, otherType, this.getClass(), otherType.getClass());
        }
        // Return true if this is the same as otherType, or if one of this's supertypes is a subtype of
        // otherType.
        if (otherType.isObject()) {
            return true;
        }
        // This handles two cases: this==otherType, or otherType==Object
        if (super.isSubtypeOf(otherType)) {
            return true;
        }
        if ((this instanceof NonParameterizedType) && otherType.isGeneric() && (this.getRuntimeClass() == otherType.getRuntimeClass())) {
            return true;
        }
        if (!otherType.isReferenceType()) {
            return false;
        }
        // Check all the supertypes of this:  that is, interfaces and superclasses.
        // First, check interfaces (only if otherType is an interface)
        if (otherType.isInterface()) {
            for (ClassOrInterfaceType iface : getInterfaces()) {
                // directly implemented interfaces
                if (debug) {
                    System.out.printf("  iface: %s%n", StringsPlume.toStringAndClass(iface));
                }
                if (iface.equals(otherType)) {
                    return true;
                }
                if (iface.isSubtypeOf(otherType)) {
                    return true;
                }
            }
            // a superclass might implement otherType
        }
        // Second, check superclasses
        // If this type is an interface, it has no superclasses, so there is nothing to do
        if (this.isInterface()) {
            return false;
        }
        ClassOrInterfaceType superClassType = this.getSuperclass();
        if (debug) {
            System.out.printf("  superClassType: %s%n", superClassType);
        }
        if (superClassType == null || superClassType.isObject()) {
            // Search has failed; stop.
            return false;
        }
        // Check whether superclass is a subtype of otherType.
        return superClassType.isSubtypeOf(otherType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasWildcard(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean hasCaptureVariable(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return false;
    }

    /**
     * Sets the enclosing type for this class type.
     *
     * @param enclosingType the type for the class enclosing the declaration of this type
     */
    protected void setEnclosingType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType enclosingType) {
        this.enclosingType = enclosingType;
    }

    /**
     * Returns the type arguments for this type.
     *
     * @return the list of type arguments
     */
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<TypeArgument> getTypeArguments(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return new ArrayList<>(0);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<TypeVariable> getTypeParameters(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        if (this.isMemberClass()) {
            return enclosingType.getTypeParameters();
        }
        return new ArrayList<>(0);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isClassOrInterfaceType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType this) {
        return true;
    }
}
