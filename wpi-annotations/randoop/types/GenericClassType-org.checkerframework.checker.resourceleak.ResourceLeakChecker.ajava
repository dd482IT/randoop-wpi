package randoop.types;

import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Objects;
import org.plumelib.util.CollectionsPlume;

/**
 * Represents the type of a generic class. Related to concrete {@link InstantiatedType} by
 * instantiating with a {@link Substitution}.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class GenericClassType extends ParameterizedType {

    /**
     * The rawtype of the generic class.
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> rawType;

    /**
     * The type parameters of the generic class.
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<TypeVariable> parameters;

    /**
     * Creates a {@link GenericClassType} for the given raw type.
     *
     * @param rawType the {@code Class} raw type
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getTypeParameters" })
    GenericClassType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> rawType) {
        this.rawType = rawType;
        this.parameters = CollectionsPlume.mapList(TypeVariable::forType, rawType.getTypeParameters());
    }

    /**
     * {@inheritDoc}
     *
     * <p>Checks that the rawtypes are the same. This is sufficient since the type parameters and
     * their bounds can be reconstructed from the Class object. Also, parameters can be distinct
     * depending on how this object is constructed.
     *
     * @return true if two generic classes have the same rawtype, false otherwise
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof GenericClassType)) {
            return false;
        }
        GenericClassType t = (GenericClassType) obj;
        return this.rawType.equals(t.rawType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return Objects.hash(rawType);
    }

    /**
     * Instantiates this generic class using the substitution to replace the type parameters.
     *
     * @param substitution the type substitution
     * @return a {@link ParameterizedType} instantiating this generic class by the given substitution
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "isMemberClass", "isNestedClass", "substitute" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InstantiatedType substitute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution) {
        List<TypeArgument> argumentList = CollectionsPlume.mapList((TypeVariable variable) -> TypeArgument.forType(substitution.getOrDefault(variable, variable)), parameters);
        return (InstantiatedType) substitute(substitution, new InstantiatedType(new GenericClassType(rawType), argumentList));
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "applyCaptureConversion", "isMemberClass", "isNestedClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType applyCaptureConversion(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return (GenericClassType) applyCaptureConversion(this);
    }

    /**
     * {@inheritDoc}
     *
     * <p>Note that this method uses {@code Class.getInterfaces()} and does not preserve the
     * relationship between the type parameters of a class and its interfaces, and should not be used
     * when finding supertypes of types represented as {@link InstantiatedType} objects.
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<ClassOrInterfaceType> getInterfaces(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return CollectionsPlume.mapList(ClassOrInterfaceType::forClass, rawType.getInterfaces());
    }

    /**
     * Return the directly-implemented interface types for this generic class type, instantiated by
     * the given type {@link Substitution}.
     *
     * <p><i>This method is not public.</i> It is used when finding the interfaces of an {@link
     * InstantiatedType} using {@link InstantiatedType#getInterfaces()}, where it is important that
     * the relationship between type variables is preserved. The reflection method {@code
     * Class.getGenericInterfaces()} ensures the type variable objects are the same from a class to
     * its interfaces, which allows the use of the same substitution for both types.
     *
     * @param substitution the type substitution
     * @return the list of instantiated directly-implemented interface types of this type
     */
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<ClassOrInterfaceType> getInterfaces(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getTypeParameters", "isMemberClass", "isNestedClass" }) GenericClassType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution) {
        return CollectionsPlume.mapList((java.lang.reflect.Type type) -> ClassOrInterfaceType.forType(type).substitute(substitution), rawType.getGenericInterfaces());
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType getGenericClassType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return this;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Class<?> getRuntimeClass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return rawType;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Note that this method uses {@code Class.getSuperclass()} and does not preserve the
     * relationship between the type parameters of a class and its superclass, and should not be used
     * when finding supertypes of types represented as {@link InstantiatedType} objects.
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType getSuperclass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        Class<?> superclass = rawType.getSuperclass();
        if (superclass != null) {
            return ClassOrInterfaceType.forClass(superclass);
        } else {
            return JavaTypes.OBJECT_TYPE;
        }
    }

    /**
     * Returns the superclass type for this generic class type instantiated by the given type {@link
     * Substitution}.
     *
     * <p><i>This method is not public.</i> It is used when finding the superclass of an {@link
     * InstantiatedType} using {@link InstantiatedType#getSuperclass()}, where it is important that
     * the relationship between type variables is preserved. The reflection method {@code
     * Class.getGenericSuperclass()} ensures the type variable objects are the same from subclass to
     * superclass, which allows the use of the same substitution for both types.
     *
     * @param substitution the type substitution
     * @return the instantiated type
     */
    @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType getSuperclass(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution) {
        java.lang.reflect.Type superclass = this.rawType.getGenericSuperclass();
        if (superclass == null) {
            return JavaTypes.OBJECT_TYPE;
        }
        return ClassOrInterfaceType.forType(superclass).substitute(substitution);
    }

    // TODO: When would one want to call this?  Should we move getTypeArguments from
    // ParameterizedType to InstantiatedType?
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<TypeArgument> getTypeArguments(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return CollectionsPlume.mapList(TypeArgument::forType, parameters);
    }

    /**
     * Returns the list of type parameters of this generic class.
     *
     * @return the list of type parameters of this generic class
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getTypeParameters", "isMemberClass", "isNestedClass" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "addAll" }) List<TypeVariable> getTypeParameters(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        List<TypeVariable> params = super.getTypeParameters();
        params.addAll(parameters);
        return params;
    }

    /**
     * Creates a type substitution using the given type arguments and applies it to this type.
     *
     * @param typeArguments the type arguments
     * @return a type which is this type parameterized by the given type arguments
     * @see #substitute(Substitution)
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getTypeParameters", "isMemberClass", "isNestedClass", "substitute" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.parameters" }, methods = { "size" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InstantiatedType instantiate(ReferenceType... typeArguments) {
        if (typeArguments.length != this.getTypeParameters().size()) {
            throw new IllegalArgumentException("number of arguments and parameters must match");
        }
        Substitution substitution = new Substitution(this.getTypeParameters(), typeArguments);
        for (int i = 0; i < parameters.size(); i++) {
            if (!parameters.get(i).getUpperTypeBound().isUpperBound(typeArguments[i], substitution)) {
                throw new IllegalArgumentException("type argument " + typeArguments[i] + " does not match parameter bound " + parameters.get(i).getUpperTypeBound());
            }
        }
        return this.substitute(substitution);
    }

    /**
     * Creates a type substitution using the given type arguments and applies it to this type.
     *
     * @param typeArguments the type arguments
     * @return the type that is this type instantiated by the given type arguments
     * @see #substitute(Substitution)
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "size" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getTypeParameters", "isMemberClass", "isNestedClass", "substitute" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.parameters" }, methods = { "size" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InstantiatedType instantiate(List<ReferenceType> typeArguments) {
        if (typeArguments.size() != this.getTypeParameters().size()) {
            throw new IllegalArgumentException("number of arguments and parameters must match");
        }
        Substitution substitution = new Substitution(this.getTypeParameters(), typeArguments);
        for (int i = 0; i < parameters.size(); i++) {
            if (!parameters.get(i).getUpperTypeBound().isUpperBound(typeArguments.get(i), substitution)) {
                throw new IllegalArgumentException("type argument " + typeArguments.get(i) + " does not match parameter bound " + parameters.get(i).getUpperTypeBound());
            }
        }
        return this.substitute(substitution);
    }

    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isAbstract(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return Modifier.isAbstract(Modifier.classModifiers() & rawType.getModifiers());
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isGeneric(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean ignoreWildcards) {
        return true;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.rawType" }, methods = { "isInterface" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isInterface(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return rawType.isInterface();
    }

    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isStatic(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return Modifier.isStatic(rawType.getModifiers() & Modifier.classModifiers());
    }

    /**
     * {@inheritDoc}
     *
     * <p>Handles the specific cases of supertypes of a generic class {@code C<F1,...,Fn>} for which
     * the direct supertypes are:
     *
     * <ol>
     *   <li>the direct superclass,
     *   <li>the direct superinterfaces,
     *   <li>the type {@code Object}, and
     *   <li>the raw type {@code C}
     * </ol>
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "equals", "isObject" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getClass", "isSubtypeOf" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isSubtypeOf(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type otherType) {
        if (otherType == null) {
            throw new IllegalArgumentException("type must be non-null");
        }
        if (super.isSubtypeOf(otherType)) {
            return true;
        }
        return otherType.isRawtype() && otherType.runtimeClassIs(this.getRuntimeClass());
    }

    /**
     * Returns the rawtype {@code Type} for this generic class.
     *
     * @return the rawtype for this generic class
     */
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) NonParameterizedType getRawtype(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) GenericClassType this) {
        return NonParameterizedType.forClass(rawType);
    }
}
