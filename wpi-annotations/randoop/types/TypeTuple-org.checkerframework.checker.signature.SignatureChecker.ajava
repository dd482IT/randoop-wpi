package randoop.types;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import org.plumelib.util.CollectionsPlume;
import org.plumelib.util.StringsPlume;

// TODO: why is this class needed?  Why is "Type[]" not adequate?
// (As an initial step toward that, I could make the internal representation be "Type[]".)
/**
 * {@code TypeTuple} represents an immutable ordered tuple of {@link Type} objects. Type tuples are
 * primarily used to represent the input types of operations.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
public class TypeTuple implements Iterable<Type>, Comparable<TypeTuple> {

    /**
     * The sequence of types in this type tuple.
     */
    private final @org.checkerframework.checker.signature.qual.SignatureUnknown ArrayList<Type> list;

    /**
     * Creates a type tuple from the list of types, preserving the order.
     *
     * @param list the list of types
     */
    public TypeTuple(@org.checkerframework.checker.signature.qual.SignatureUnknown List<Type> list) {
        this.list = new ArrayList<>(list);
    }

    /**
     * Creates an empty type tuple.
     */
    public TypeTuple() {
        this(new ArrayList<Type>(0));
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean equals(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this, @org.checkerframework.checker.signature.qual.SignatureUnknown Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof TypeTuple)) {
            return false;
        }
        TypeTuple tuple = (TypeTuple) obj;
        return list.equals(tuple.list);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int hashCode(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        return Objects.hash(list);
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.signature.qual.SignatureUnknown String toString(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        return "(" + StringsPlume.join(", ", list) + ")";
    }

    /**
     * Applies a substitution to a type tuple, replacing any occurrences of type variables. Resulting
     * tuple may only be partially instantiated. Returns a new TypeTuple; the receiver is not
     * side-effected.
     *
     * @param substitution the substitution
     * @return a new type tuple resulting from applying the given substitution to this tuple
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple substitute(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        List<Type> typeList = new ArrayList<>(this.list.size());
        for (Type type : this.list) {
            Type newType = type.substitute(substitution);
            if (newType != null) {
                typeList.add(newType);
            } else {
                typeList.add(type);
            }
        }
        return new TypeTuple(typeList);
    }

    /**
     * Applies a capture conversion to each component of this type type tuple. Returns a new
     * TypeTuple; the receiver is not side-effected.
     *
     * @return a new type tuple after performing a capture conversion
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple applyCaptureConversion(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        List<Type> typeList = CollectionsPlume.mapList(Type::applyCaptureConversion, this.list);
        return new TypeTuple(typeList);
    }

    /**
     * Return the ith component type of this tuple.
     *
     * @param i the component index
     * @return the component type at the position
     */
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.signature.qual.SignatureUnknown Type get(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this,  @org.checkerframework.checker.signature.qual.SignatureUnknown int i) {
        return list.get(i);
    }

    /**
     * Returns the type parameters that occur in any component of this type tuple.
     *
     * @return the list of type parameters for this type tuple
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown List<TypeVariable> getTypeParameters(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        Set<TypeVariable> paramSet = new LinkedHashSet<>(this.list.size());
        for (Type type : this.list) {
            if (type.isReferenceType()) {
                paramSet.addAll(((ReferenceType) type).getTypeParameters());
            }
        }
        return new ArrayList<>(paramSet);
    }

    /**
     * Indicates whether any of the types in this type tuple contains a wildcard.
     *
     * @return true if there is at least one wildcard occurrence
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean hasWildcard(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        for (Type type : list) {
            if (type.isParameterized() && ((ParameterizedType) type).hasWildcard()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Indicates whether any of the types in this type tuple contains a capture variable.
     *
     * @return true if there is at least one capture variable occurrence
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean hasCaptureVariable() {
        for (Type type : list) {
            if (type.isParameterized() && ((ParameterizedType) type).hasCaptureVariable()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Indicates whether the tuple is empty.
     *
     * @return true if the tuple has no components, false otherwise
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isEmpty(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        return list.isEmpty();
    }

    /**
     * Return the number of components of the tuple.
     *
     * @return the number of components of this tuple
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int size(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        return list.size();
    }

    /**
     * Indicates whether the tuple has any generic components.
     *
     * @param ignoreWildcards if true, disregard wildcards when checking for generics
     * @return true if any component of tuple is generic, false if none are
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isGeneric(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this,  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean ignoreWildcards) {
        for (Type type : list) {
            if (type.isGeneric(ignoreWildcards)) {
                return true;
            }
        }
        return false;
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown Iterator<Type> iterator(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this) {
        return new TypeIterator(list.iterator());
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int compareTo(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple this, @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple tuple) {
        if (this.size() < tuple.size()) {
            return -1;
        }
        if (this.size() > tuple.size()) {
            return 1;
        }
        int result = 0;
        for (int i = 0; i < this.size() && result == 0; i++) {
            result = list.get(i).compareTo(tuple.list.get(i));
        }
        return result;
    }

    private static class TypeIterator implements Iterator<Type> {

        private @org.checkerframework.checker.signature.qual.SignatureUnknown Iterator<Type> iterator;

        public TypeIterator(@org.checkerframework.checker.signature.qual.SignatureUnknown Iterator<Type> iterator) {
            this.iterator = iterator;
        }

        @org.checkerframework.dataflow.qual.Pure
        public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean hasNext(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeIterator this) {
            return iterator.hasNext();
        }

        public @org.checkerframework.checker.signature.qual.SignatureUnknown Type next(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeIterator this) {
            return iterator.next();
        }

        @org.checkerframework.dataflow.qual.Pure
        public void remove(@org.checkerframework.checker.signature.qual.SignatureUnknown TypeIterator this) {
            throw new UnsupportedOperationException();
        }
    }
}
