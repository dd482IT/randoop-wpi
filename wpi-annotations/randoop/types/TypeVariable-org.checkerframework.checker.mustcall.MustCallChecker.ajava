package randoop.types;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

/**
 * An abstract class representing type variables.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.mustcall.MustCallChecker")
public abstract class TypeVariable extends ParameterType {

    /**
     * Creates a type variable with {@link NullReferenceType} as the lower bound, and the {@code
     * Object} type as upper bound.
     */
    TypeVariable() {
        super();
    }

    /**
     * Creates a type variable with the given type bounds. Assumes the bounds are consistent and does
     * not check for the subtype relationship.
     *
     * @param lowerBound the lower type bound on this variable
     * @param upperBound the upper type bound on this variable
     */
    TypeVariable(@org.checkerframework.checker.mustcall.qual.MustCall({}) ParameterBound lowerBound, @org.checkerframework.checker.mustcall.qual.MustCall({}) ParameterBound upperBound) {
        super(lowerBound, upperBound);
    }

    /**
     * Creates a {@code TypeVariable} object for a given {@code java.lang.reflect.Type} reference,
     * which must be a {@code java.lang.reflect.TypeVariable}.
     *
     * @param type the type reference
     * @return the {@code TypeVariable} for the given type
     */
    public static @org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable forType(java.lang.reflect.@org.checkerframework.checker.mustcall.qual.MustCall({}) Type type) {
        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {
            throw new IllegalArgumentException("type must be a type variable, got " + type);
        }
        java.lang.reflect.TypeVariable<?> v = (java.lang.reflect.TypeVariable) type;
        Set<java.lang.reflect.TypeVariable<?>> variableSet = new HashSet<>(1);
        variableSet.add(v);
        return new ExplicitTypeVariable(v, ParameterBound.forTypes(variableSet, v.getBounds()));
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) ReferenceType substitute(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Substitution substitution) {
        ReferenceType type = substitution.get(this);
        if (type != null) {
            return type;
        }
        return this;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Returns false, since an uninstantiated type variable may not be assigned to.
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean isAssignableFrom(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Type sourceType) {
        return false;
    }

    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean isInstantiationOf(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) ReferenceType otherType) {
        if (super.isInstantiationOf(otherType)) {
            return true;
        }
        if (otherType.isVariable()) {
            TypeVariable otherVariable = (TypeVariable) otherType;
            Substitution substitution = getSubstitution(otherVariable, this);
            boolean lowerboundOk = otherVariable.getLowerTypeBound().isLowerBound(getLowerTypeBound(), substitution);
            boolean upperboundOk = otherVariable.getUpperTypeBound().isUpperBound(getUpperTypeBound(), substitution);
            return lowerboundOk && upperboundOk;
        }
        return false;
    }

    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean isSubtypeOf(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Type otherType) {
        if (super.isSubtypeOf(otherType)) {
            return true;
        }
        if (otherType.isReferenceType()) {
            Substitution substitution = getSubstitution(this, (ReferenceType) otherType);
            return this.getUpperTypeBound().isLowerBound(otherType, substitution);
        }
        return false;
    }

    /**
     * Creates a substitution of the given {@link ReferenceType} for the {@link TypeVariable}.
     *
     * @param variable the variable
     * @param otherType the replacement type
     * @return a substitution that replaces {@code variable} with {@code otherType}
     */
    private static @org.checkerframework.checker.mustcall.qual.MustCall({}) Substitution getSubstitution(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable variable, @org.checkerframework.checker.mustcall.qual.MustCall({}) ReferenceType otherType) {
        return new Substitution(variable, otherType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean isVariable(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this) {
        return true;
    }

    /**
     * Indicates whether this {@link TypeVariable} can be instantiated by the {@link ReferenceType}.
     * Does not require that all bounds of this variable be instantiated.
     *
     * @param otherType the possibly instantiating type, not a variable
     * @return true if the given type can instantiate this variable, false otherwise
     */
     @org.checkerframework.checker.mustcall.qual.MustCall({}) boolean canBeInstantiatedBy(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) ReferenceType otherType) {
        Substitution substitution;
        if (getLowerTypeBound().isVariable()) {
            substitution = getSubstitution(this, otherType);
            ParameterBound boundType = getLowerTypeBound().substitute(substitution);
            TypeVariable checkType = (TypeVariable) ((ReferenceBound) boundType).getBoundType();
            if (!checkType.canBeInstantiatedBy(otherType)) {
                return false;
            }
        } else {
            substitution = getSubstitution(this, otherType);
            if (!getLowerTypeBound().isLowerBound(otherType, substitution)) {
                return false;
            }
        }
        if (getUpperTypeBound().isVariable()) {
            substitution = getSubstitution(this, otherType);
            ParameterBound boundType = getUpperTypeBound().substitute(substitution);
            TypeVariable checkType = (TypeVariable) ((ReferenceBound) boundType).getBoundType();
            if (!checkType.canBeInstantiatedBy(otherType)) {
                return false;
            }
        } else {
            substitution = getSubstitution(this, otherType);
            if (!getUpperTypeBound().isUpperBound(otherType, substitution)) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the type parameters in this type, which is this variable.
     *
     * @return this variable
     */
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) List<TypeVariable> getTypeParameters(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this) {
        Set<TypeVariable> parameters = new LinkedHashSet<>(super.getTypeParameters());
        parameters.add(this);
        return new ArrayList<>(parameters);
    }

    @org.checkerframework.dataflow.qual.Pure
    public abstract @org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable createCopyWithBounds(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this, @org.checkerframework.checker.mustcall.qual.MustCall({}) ParameterBound lowerBound, @org.checkerframework.checker.mustcall.qual.MustCall({}) ParameterBound upperBound);

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) Type getRawtype(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypeVariable this) {
        return JavaTypes.OBJECT_TYPE;
    }
}
