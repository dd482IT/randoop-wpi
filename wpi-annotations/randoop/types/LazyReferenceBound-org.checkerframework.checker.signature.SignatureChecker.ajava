package randoop.types;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * A lazy representation of a type bound in which a type variable occurs. Similar in purpose to
 * {@link LazyParameterBound}, but this class uses {@link ReferenceType} as the bound instead of
 * {@code java.lang.reflect.Type}. Also, prevents access to recursive type bounds, that would
 * otherwise result in nonterminating calls to {@link #getTypeParameters()}.
 *
 * <p>Objects of this class are created by {@link LazyParameterBound#substitute(Substitution)} when
 * the substitution would replace a type variable with another type variable.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
class LazyReferenceBound extends ReferenceBound {

    LazyReferenceBound(@org.checkerframework.checker.signature.qual.SignatureUnknown ReferenceType boundType) {
        super(boundType);
    }

    /**
     * {@inheritDoc}
     *
     * <p>{@link LazyReferenceBound} can be part of a recursive type, and so the hash code is based on
     * the string representation of the bound to avoid recursive calls on {@code hashCode()}.
     *
     * @return the hashCode for the string representation of this bound
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int hashCode(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this) {
        return Objects.hash(this.toString());
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown ReferenceBound substitute(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        // if the substitution has no effect on this bound just return this
        if (substitution.isEmpty()) {
            return this;
        }
        for (TypeVariable parameter : getTypeParameters()) {
            if (substitution.get(parameter) == null) {
                return this;
            }
        }
        ReferenceType referenceType = getBoundType().substitute(substitution);
        if (referenceType.equals(getBoundType())) {
            return this;
        }
        if (getBoundType().isVariable()) {
            if (referenceType.isVariable()) {
                return new LazyReferenceBound(referenceType);
            }
            return new EagerReferenceBound(referenceType);
        }
        if (getBoundType().isParameterized()) {
            // XXX technically, need to check if variable argument was replaced by variable
            // if so should return new LazyReferenceBound(referenceType)
            // But highly unlikely so for now only including code to do else case
            return new EagerReferenceBound(referenceType);
        }
        return this;
    }

    @org.checkerframework.dataflow.qual.Pure
    public ReferenceBound applyCaptureConversion(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this) {
        return null;
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown List<TypeVariable> getTypeParameters(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this) {
        if (getBoundType().isVariable()) {
            List<TypeVariable> parameters = new ArrayList<>(1);
            parameters.add((TypeVariable) getBoundType());
            return parameters;
        } else if (getBoundType().isParameterized()) {
            List<ReferenceType> referenceArgs = ((InstantiatedType) getBoundType()).getReferenceArguments();
            List<TypeVariable> parameters = new ArrayList<>(referenceArgs.size());
            for (ReferenceType argType : referenceArgs) {
                if (argType.isVariable()) {
                    parameters.add((TypeVariable) argType);
                }
            }
            return parameters;
        } else {
            return new ArrayList<>(0);
        }
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isLowerBound(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Type argType, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        ReferenceBound b = this.substitute(substitution);
        return !this.equals(b) && b.isLowerBound(argType, substitution);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isSubtypeOf(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown ParameterBound boundType) {
        assert false : "subtype not implemented for LazyReferenceBound";
        return false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isUpperBound(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Type argType, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        ReferenceBound b = this.substitute(substitution);
        return !this.equals(b) && b.isUpperBound(argType, substitution);
    }

    @org.checkerframework.dataflow.qual.Pure
     @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isUpperBound(@org.checkerframework.checker.signature.qual.SignatureUnknown LazyReferenceBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown ParameterBound bound, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        assert false : "isUpperBound(ParameterBound, Substitution) not implemented";
        return false;
    }
}
