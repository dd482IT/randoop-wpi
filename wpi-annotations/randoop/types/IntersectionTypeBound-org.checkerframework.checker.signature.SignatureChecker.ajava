package randoop.types;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import org.plumelib.util.CollectionsPlume;
import org.plumelib.util.StringsPlume;

/**
 * Represents an intersection type bound on a type parameter in a class, interface, method or
 * constructor (see <a
 * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.4">JLS section
 * 4.4</a>). Alternatively, in capture conversion, it may also represent the greatest lower bound of
 * two upper bounds ( <a
 * href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html#jls-5.1.10">JLS section
 * 5.1.10</a>).
 *
 * <p>Java requires that an intersection type bound consist of class and interface types, with at
 * most one class, and if there is a class it appears in the conjunction term first. This class
 * preserves the order of the types. In a capture conversion, if both types are classes, one must be
 * a subclass of the other.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
class IntersectionTypeBound extends ParameterBound {

    /**
     * the list of type bounds for the intersection bound
     */
    private @org.checkerframework.checker.signature.qual.SignatureUnknown List<ParameterBound> boundList;

    /**
     * Create an intersection type bound from the list of type bounds.
     *
     * @param boundList the list of type bounds
     */
    IntersectionTypeBound(@org.checkerframework.checker.signature.qual.SignatureUnknown List<ParameterBound> boundList) {
        if (boundList == null) {
            throw new IllegalArgumentException("bounds list may not be null");
        }
        this.boundList = boundList;
    }

    // XXX could be relaxed: only require that the first argument be first, if it is a class (rest can
    // be reordered)
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean equals(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof IntersectionTypeBound)) {
            return false;
        }
        IntersectionTypeBound b = (IntersectionTypeBound) obj;
        return this.boundList.equals(b.boundList);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int hashCode(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        return Objects.hash(boundList);
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.signature.qual.SignatureUnknown String toString(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        return StringsPlume.join(" & ", boundList);
    }

    /**
     * {@inheritDoc}
     *
     * @return this bound with the substitution applied to all member bounds
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound substitute(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        List<ParameterBound> bounds = CollectionsPlume.mapList((ParameterBound bound) -> bound.substitute(substitution), this.boundList);
        return new IntersectionTypeBound(bounds);
    }

    /**
     * {@inheritDoc}
     *
     * @return an intersection bound with capture conversion applied to all member bounds
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown ParameterBound applyCaptureConversion(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        List<ParameterBound> convertedBoundList = CollectionsPlume.mapList(ParameterBound::applyCaptureConversion, boundList);
        return new IntersectionTypeBound(convertedBoundList);
    }

    /**
     * {@inheritDoc}
     *
     * @return the list of type variables occurring in all of the type bounds of this intersection
     *     bound
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown List<TypeVariable> getTypeParameters(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        List<TypeVariable> paramList = new ArrayList<>(boundList.size());
        for (ParameterBound b : boundList) {
            paramList.addAll(b.getTypeParameters());
        }
        return paramList;
    }

    @org.checkerframework.dataflow.qual.Pure
     @org.checkerframework.checker.signature.qual.SignatureUnknown boolean hasWildcard(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        for (ParameterBound b : boundList) {
            if (b.hasWildcard()) {
                return true;
            }
        }
        return false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean hasCaptureVariable(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        for (ParameterBound b : boundList) {
            if (b.hasCaptureVariable()) {
                return true;
            }
        }
        return false;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isGeneric(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this,  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean ignoreWildcards) {
        for (ParameterBound b : boundList) {
            if (b.isGeneric(ignoreWildcards)) {
                return true;
            }
        }
        return false;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Specifically, this method checks that the argument type is a subtype of all of the member
     * bounds of this object.
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isLowerBound(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Type otherType, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution subst) {
        for (ParameterBound b : boundList) {
            if (!b.isLowerBound(otherType, subst)) {
                return false;
            }
        }
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * <p>Determines whether all types in this bound are {@code Object}.
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isObject(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this) {
        for (ParameterBound b : boundList) {
            if (!b.isObject()) {
                return false;
            }
        }
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * <p>This method should never be tested for {@link IntersectionTypeBound}. Will fail if
     * assertions are enabled.
     *
     * @return false, always
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isSubtypeOf(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown ParameterBound boundType) {
        assert false : "intersection type bound isSubTypeOf not implemented";
        return false;
    }

    /**
     * {@inheritDoc}
     *
     * @return true if the argument type satisfies all of the bounds in this intersection type bound
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isUpperBound(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown Type argType, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution subst) {
        for (ParameterBound b : boundList) {
            if (!b.isUpperBound(argType, subst)) {
                return false;
            }
        }
        return true;
    }

    /**
     * {@inheritDoc}
     *
     * @return true if the argument bound has all of the member bounds of this object as an upper
     *     bound
     */
    @org.checkerframework.dataflow.qual.Pure
     @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isUpperBound(@org.checkerframework.checker.signature.qual.SignatureUnknown IntersectionTypeBound this, @org.checkerframework.checker.signature.qual.SignatureUnknown ParameterBound bound, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        for (ParameterBound b : boundList) {
            if (!b.isUpperBound(bound, substitution)) {
                return false;
            }
        }
        return true;
    }
}
