package randoop.operation;

import randoop.ExceptionalExecution;
import randoop.ExecutionOutcome;
import randoop.NormalExecution;
import randoop.condition.ExecutableSpecification;
import randoop.types.ClassOrInterfaceType;
import randoop.types.Substitution;
import randoop.types.Type;
import randoop.types.TypeTuple;

/**
 * Represents a method with a return type that is a type variable that must be instantiated, and for
 * which execution performs a cast to the instantiating type to emulate handling of casts that are
 * not done in reflection.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.mustcall.MustCallChecker")
public class TypedClassOperationWithCast extends TypedClassOperation {

    TypedClassOperationWithCast(@org.checkerframework.checker.mustcall.qual.MustCall({}) CallableOperation op, @org.checkerframework.checker.mustcall.qual.MustCall({}) ClassOrInterfaceType declaringType, @org.checkerframework.checker.mustcall.qual.MustCall({}) TypeTuple inputTypes, @org.checkerframework.checker.mustcall.qual.MustCall({}) Type outputType) {
        this(op, declaringType, inputTypes, outputType, null);
    }

    TypedClassOperationWithCast(@org.checkerframework.checker.mustcall.qual.MustCall({}) CallableOperation op, @org.checkerframework.checker.mustcall.qual.MustCall({}) ClassOrInterfaceType declaringType, @org.checkerframework.checker.mustcall.qual.MustCall({}) TypeTuple inputTypes, @org.checkerframework.checker.mustcall.qual.MustCall({}) Type outputType, @org.checkerframework.checker.mustcall.qual.MustCall({}) ExecutableSpecification execSpec) {
        super(op, declaringType, inputTypes, outputType, execSpec);
    }

    public @org.checkerframework.checker.mustcall.qual.MustCall({}) TypedClassOperationWithCast substitute(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypedClassOperationWithCast this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Substitution substitution) {
        if (substitution.isEmpty()) {
            return this;
        }
        ClassOrInterfaceType declaringType = getDeclaringType().substitute(substitution);
        TypeTuple inputTypes = this.getInputTypes().substitute(substitution);
        Type outputType = this.getOutputType().substitute(substitution);
        return new TypedClassOperationWithCast(this.getOperation(), declaringType, inputTypes, outputType, this.getExecutableSpecification());
    }

    public @org.checkerframework.checker.mustcall.qual.MustCall({}) TypedClassOperationWithCast applyCaptureConversion(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypedClassOperationWithCast this) {
        return new TypedClassOperationWithCast(this.getOperation(), this.getDeclaringType(), this.getInputTypes().applyCaptureConversion(), this.getOutputType(), this.getExecutableSpecification());
    }

    /**
     * {@inheritDoc}
     *
     * <p>Performs cast to output type of this operation to ensure that any {@code ClassCastException}
     * that would be thrown in JVM execution is also thrown.
     */
    public @org.checkerframework.checker.mustcall.qual.MustCall({}) ExecutionOutcome execute(@org.checkerframework.checker.mustcall.qual.MustCall({}) TypedClassOperationWithCast this, @org.checkerframework.checker.mustcall.qual.MustCall({}) Object @org.checkerframework.checker.mustcall.qual.MustCall({}) [] input) {
        ExecutionOutcome outcome = super.execute(input);
        if (outcome instanceof NormalExecution) {
            NormalExecution execution = (NormalExecution) outcome;
            Object result;
            try {
                result = getOutputType().getRuntimeClass().cast(execution.getRuntimeValue());
            } catch (ClassCastException e) {
                return new ExceptionalExecution(e, 0);
            }
            if (result != null) {
                return new NormalExecution(result, execution.getExecutionTime());
            }
        }
        return outcome;
    }
}
