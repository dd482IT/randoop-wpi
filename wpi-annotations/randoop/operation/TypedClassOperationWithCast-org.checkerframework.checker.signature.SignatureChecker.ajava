package randoop.operation;

import randoop.ExceptionalExecution;
import randoop.ExecutionOutcome;
import randoop.NormalExecution;
import randoop.condition.ExecutableSpecification;
import randoop.types.ClassOrInterfaceType;
import randoop.types.Substitution;
import randoop.types.Type;
import randoop.types.TypeTuple;

/**
 * Represents a method with a return type that is a type variable that must be instantiated, and for
 * which execution performs a cast to the instantiating type to emulate handling of casts that are
 * not done in reflection.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
public class TypedClassOperationWithCast extends TypedClassOperation {

    TypedClassOperationWithCast(@org.checkerframework.checker.signature.qual.SignatureUnknown CallableOperation op, @org.checkerframework.checker.signature.qual.SignatureUnknown ClassOrInterfaceType declaringType, @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple inputTypes, @org.checkerframework.checker.signature.qual.SignatureUnknown Type outputType) {
        this(op, declaringType, inputTypes, outputType, null);
    }

    TypedClassOperationWithCast(@org.checkerframework.checker.signature.qual.SignatureUnknown CallableOperation op, @org.checkerframework.checker.signature.qual.SignatureUnknown ClassOrInterfaceType declaringType, @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple inputTypes, @org.checkerframework.checker.signature.qual.SignatureUnknown Type outputType, @org.checkerframework.checker.signature.qual.SignatureUnknown ExecutableSpecification execSpec) {
        super(op, declaringType, inputTypes, outputType, execSpec);
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypedClassOperationWithCast substitute(@org.checkerframework.checker.signature.qual.SignatureUnknown TypedClassOperationWithCast this, @org.checkerframework.checker.signature.qual.SignatureUnknown Substitution substitution) {
        if (substitution.isEmpty()) {
            return this;
        }
        ClassOrInterfaceType declaringType = getDeclaringType().substitute(substitution);
        TypeTuple inputTypes = this.getInputTypes().substitute(substitution);
        Type outputType = this.getOutputType().substitute(substitution);
        return new TypedClassOperationWithCast(this.getOperation(), declaringType, inputTypes, outputType, this.getExecutableSpecification());
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypedClassOperationWithCast applyCaptureConversion(@org.checkerframework.checker.signature.qual.SignatureUnknown TypedClassOperationWithCast this) {
        return new TypedClassOperationWithCast(this.getOperation(), this.getDeclaringType(), this.getInputTypes().applyCaptureConversion(), this.getOutputType(), this.getExecutableSpecification());
    }

    /**
     * {@inheritDoc}
     *
     * <p>Performs cast to output type of this operation to ensure that any {@code ClassCastException}
     * that would be thrown in JVM execution is also thrown.
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown ExecutionOutcome execute(@org.checkerframework.checker.signature.qual.SignatureUnknown TypedClassOperationWithCast this, @org.checkerframework.checker.signature.qual.SignatureUnknown Object @org.checkerframework.checker.signature.qual.SignatureUnknown [] input) {
        ExecutionOutcome outcome = super.execute(input);
        if (outcome instanceof NormalExecution) {
            NormalExecution execution = (NormalExecution) outcome;
            Object result;
            try {
                result = getOutputType().getRuntimeClass().cast(execution.getRuntimeValue());
            } catch (ClassCastException e) {
                return new ExceptionalExecution(e, 0);
            }
            if (result != null) {
                return new NormalExecution(result, execution.getExecutionTime());
            }
        }
        return outcome;
    }
}
