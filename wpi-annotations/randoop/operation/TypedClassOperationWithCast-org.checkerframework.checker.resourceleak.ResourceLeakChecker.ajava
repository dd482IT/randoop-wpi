package randoop.operation;

import randoop.ExceptionalExecution;
import randoop.ExecutionOutcome;
import randoop.NormalExecution;
import randoop.condition.ExecutableSpecification;
import randoop.types.ClassOrInterfaceType;
import randoop.types.Substitution;
import randoop.types.Type;
import randoop.types.TypeTuple;

/**
 * Represents a method with a return type that is a type variable that must be instantiated, and for
 * which execution performs a cast to the instantiating type to emulate handling of casts that are
 * not done in reflection.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class TypedClassOperationWithCast extends TypedClassOperation {

    TypedClassOperationWithCast(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isStatic" }) CallableOperation op, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType declaringType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypeTuple inputTypes, @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isVariable" }) Type outputType) {
        this(op, declaringType, inputTypes, outputType, null);
    }

    TypedClassOperationWithCast(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CallableOperation op, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceType declaringType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypeTuple inputTypes, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type outputType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ExecutableSpecification execSpec) {
        super(op, declaringType, inputTypes, outputType, execSpec);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "isEmpty" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getDeclaringType", "getExecutableSpecification", "getInputTypes", "getOperation", "getOutputType" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedClassOperationWithCast substitute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedClassOperationWithCast this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Substitution substitution) {
        if (substitution.isEmpty()) {
            return this;
        }
        ClassOrInterfaceType declaringType = getDeclaringType().substitute(substitution);
        TypeTuple inputTypes = this.getInputTypes().substitute(substitution);
        Type outputType = this.getOutputType().substitute(substitution);
        return new TypedClassOperationWithCast(this.getOperation(), declaringType, inputTypes, outputType, this.getExecutableSpecification());
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getDeclaringType", "getExecutableSpecification", "getInputTypes", "getOperation", "getOutputType" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedClassOperationWithCast applyCaptureConversion(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedClassOperationWithCast this) {
        return new TypedClassOperationWithCast(this.getOperation(), this.getDeclaringType(), this.getInputTypes().applyCaptureConversion(), this.getOutputType(), this.getExecutableSpecification());
    }

    /**
     * {@inheritDoc}
     *
     * <p>Performs cast to output type of this operation to ensure that any {@code ClassCastException}
     * that would be thrown in JVM execution is also thrown.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "execute", "getOperation" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ExecutionOutcome execute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedClassOperationWithCast this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] input) {
        ExecutionOutcome outcome = super.execute(input);
        if (outcome instanceof NormalExecution) {
            NormalExecution execution = (NormalExecution) outcome;
            Object result;
            try {
                result = getOutputType().getRuntimeClass().cast(execution.getRuntimeValue());
            } catch (ClassCastException e) {
                return new ExceptionalExecution(e, 0);
            }
            if (result != null) {
                return new NormalExecution(result, execution.getExecutionTime());
            }
        }
        return outcome;
    }
}
