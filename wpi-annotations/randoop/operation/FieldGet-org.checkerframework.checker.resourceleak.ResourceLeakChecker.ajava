package randoop.operation;

import java.util.ArrayList;
import java.util.List;
import randoop.ExceptionalExecution;
import randoop.ExecutionOutcome;
import randoop.NormalExecution;
import randoop.field.AccessibleField;
import randoop.field.FieldParser;
import randoop.main.RandoopBug;
import randoop.reflection.ReflectionPredicate;
import randoop.sequence.SequenceExecutionException;
import randoop.sequence.Variable;
import randoop.types.ClassOrInterfaceType;
import randoop.types.Type;
import randoop.types.TypeTuple;

/**
 * FieldGetter is an adapter that creates a {@link Operation} from a {@link AccessibleField} and
 * behaves like a getter for the field.
 *
 * @see AccessibleField
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class FieldGet extends CallableOperation {

    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isStatic" }) AccessibleField field;

    /**
     * FieldGetter sets the public field for the getter statement.
     *
     * @param field the {@link AccessibleField} object from which to get values
     */
    public FieldGet(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isStatic" }) AccessibleField field) {
        this.field = field;
    }

    /**
     * Performs computation of getting value of field or capturing thrown exceptions. Exceptions
     * should only be NullPointerException, which happens when input is null but field is an instance
     * field. {@link AccessibleField#getValue(Object)} suppresses exceptions that occur because field
     * is not valid or accessible.
     *
     * @param statementInput the inputs for statement
     * @return outcome of access
     * @throws RandoopBug if field access throws bug exception
     * @throws SequenceExecutionException if field access has a type exception
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "getValue" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ExecutionOutcome execute(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] statementInput) {
        // either 0 or 1 inputs. If none use null, otherwise give object.
        Object input = statementInput.length == 0 ? null : statementInput[0];
        try {
            Object value = field.getValue(input);
            return new NormalExecution(value, 0);
        } catch (RandoopBug | SequenceExecutionException e) {
            throw e;
        } catch (Throwable thrown) {
            return new ExceptionalExecution(thrown, 0);
        }
    }

    /**
     * Adds the text for an initialization of a variable from a field to the StringBuilder.
     *
     * @param inputVars the list of variables to be used
     * @param b the StringBuilder that strings are appended to
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#5" }, methods = { "append" })
    public void appendCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type declaringType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypeTuple inputTypes, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type outputType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) List<Variable> inputVars, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) StringBuilder b) {
        b.append(field.toCode(declaringType, inputVars));
    }

    /**
     * Returns string descriptor for field that can be parsed by PublicFieldParser.
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getBinaryName" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "getName", "isStatic" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toParsableString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type declaringType, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypeTuple inputTypes, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type outputType) {
        return declaringType.getBinaryName() + ".<get>(" + field.getName() + ")";
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "isStatic", "toString" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return field.toString();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "getName", "isStatic" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return "<get>(" + field.getName() + ")";
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof FieldGet)) {
            return false;
        }
        FieldGet s = (FieldGet) obj;
        return field.equals(s.field);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "hashCode", "isStatic" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return field.hashCode();
    }

    /**
     * Parses a getter for a field from a string. A getter description has the form "{@code <get>(
     * field-descriptor )}" where "{@code <get>}" is literal ("{@code <}" and "{@code >}" included),
     * and field-descriptor is as recognized by
     *
     * @param descr the string containing descriptor of getter for a field
     * @return the getter operation for the given string descriptor
     * @throws OperationParseException if any error in descriptor string
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "indexOf", "substring" })
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) TypedOperation parse(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String descr) throws OperationParseException {
        String errorPrefix = "Error parsing " + descr + " as description for field getter statement: ";
        int openParPos = descr.indexOf('(');
        int closeParPos = descr.indexOf(')');
        if (openParPos < 0) {
            String msg = errorPrefix + " expecting parentheses.";
            throw new OperationParseException(msg);
        }
        String prefix = descr.substring(0, openParPos);
        int lastDotPos = prefix.lastIndexOf('.');
        assert lastDotPos > 0 : "should be a period after the classname: " + descr;
        String classname = prefix.substring(0, lastDotPos);
        String opname = prefix.substring(lastDotPos + 1);
        assert opname.equals("<get>") : "expecting <get>, saw " + opname;
        if (closeParPos < 0) {
            String msg = errorPrefix + " no closing parentheses found.";
            throw new OperationParseException(msg);
        }
        String fieldname = descr.substring(openParPos + 1, closeParPos);
        AccessibleField accessibleField = FieldParser.parse(descr, classname, fieldname);
        ClassOrInterfaceType classType = accessibleField.getDeclaringType();
        Type fieldType = Type.forType(accessibleField.getRawField().getGenericType());
        List<Type> getInputTypeList = new ArrayList<>(1);
        if (!accessibleField.isStatic()) {
            getInputTypeList.add(classType);
        }
        return new TypedClassOperation(new FieldGet(accessibleField), classType, new TypeTuple(getInputTypeList), fieldType);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isStatic(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return field.isStatic();
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isConstantField(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return field.isStatic() && field.isFinal();
    }

    /**
     * {@inheritDoc}
     *
     * @return true, always
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean isMessage(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this) {
        return true;
    }

    /**
     * Determines whether enclosed {@link java.lang.reflect.Field} satisfies the given predicate.
     *
     * @param reflectionPredicate the {@link ReflectionPredicate} to be checked
     * @return true only if the field used in this getter satisfies predicate.canUse
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "test" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.field" }, methods = { "isStatic", "satisfies" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean satisfies(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) FieldGet this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ReflectionPredicate reflectionPredicate) {
        return field.satisfies(reflectionPredicate);
    }
}
