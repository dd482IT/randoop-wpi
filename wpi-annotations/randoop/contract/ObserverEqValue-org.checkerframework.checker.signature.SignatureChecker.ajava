package randoop.contract;

import java.lang.reflect.Executable;
import java.util.Arrays;
import java.util.Objects;
import org.plumelib.util.StringsPlume;
import randoop.main.RandoopBug;
import randoop.operation.CallableOperation;
import randoop.operation.TypedOperation;
import randoop.sequence.Value;
import randoop.types.JavaTypes;
import randoop.types.Type;
import randoop.types.TypeTuple;

/**
 * A check recording the value that an observer method returned during execution, e.g. a check
 * recording that a collection's {@code size()} method returned {@code 3}.
 *
 * <p>ObserverEqValue checks are not checks that must hold of all objects of a given class (unlike a
 * check like {@link EqualsReflexive}, which must hold for any objects, no matter its execution
 * context).
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
public final class ObserverEqValue extends ObjectContract {

    /**
     * The observer method.
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypedOperation observer;

    /**
     * The run-time result of calling the observer: a primitive value or String.
     */
    public @org.checkerframework.checker.signature.qual.SignatureUnknown Object value;

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean equals(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this, @org.checkerframework.checker.signature.qual.SignatureUnknown Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof ObserverEqValue)) {
            return false;
        }
        ObserverEqValue other = (ObserverEqValue) o;
        return observer.equals(other.observer) && Objects.equals(value, other.value);
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int hashCode(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return Objects.hash(observer, value);
    }

    /**
     * Create a new ObserverEqValue.
     *
     * @param observer the observer method
     * @param value the run-time result of calling the observer: a primitive value or String
     */
    public ObserverEqValue(@org.checkerframework.checker.signature.qual.SignatureUnknown TypedOperation observer, @org.checkerframework.checker.signature.qual.SignatureUnknown Object value) {
        assert observer.isMethodCall() || observer.isConstructorCall() : "Observer must be MethodCall or ConstructorCall, got " + observer;
        this.observer = observer;
        this.value = value;
        if (!isLiteralValue(value)) {
            throw new RandoopBug(String.format("Cannot represent %s as a literal; observer = %s", StringsPlume.toStringAndClass(value), observer));
        }
    }

    /**
     * Returns true if the argument can be written as a literal in Java source code.
     *
     * @param value the value to be tested
     * @return true if the argument can be written as a literal in Java source code
     */
    public static  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isLiteralValue(@org.checkerframework.checker.signature.qual.SignatureUnknown Object value) {
        if (value == null) {
            return true;
        }
        Class<?> cls = value.getClass();
        if (cls == Class.class || cls == String.class || cls.isEnum()) {
            return true;
        }
        Type type = Type.forClass(cls);
        if (type.isBoxedPrimitive()) {
            return true;
        }
        return false;
    }

    public @org.checkerframework.checker.signature.qual.SignatureUnknown String toCodeString(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        StringBuilder b = new StringBuilder();
        // It might be nicer to call TypedOperation.getOperation().appendCode(...) to obtain the printed
        // representation, but this works for this simple case.
        String call;
        {
            CallableOperation operation = observer.getOperation();
            String methodname = operation.getName();
            if (operation.isStatic()) {
                Executable m = (Executable) operation.getReflectionObject();
                String theClass = m.getDeclaringClass().getName();
                call = String.format("%s.%s(x0)", theClass, methodname);
            } else {
                call = String.format("x0.%s()", methodname);
            }
        }
        if (value == null) {
            b.append(String.format("org.junit.Assert.assertNull(\"%s == null\", %s);", call, call));
        } else if (observer.getOutputType().runtimeClassIs(boolean.class)) {
            assert value.equals(true) || value.equals(false);
            if (value.equals(true)) {
                b.append(String.format("org.junit.Assert.assertTrue(%s);", call));
            } else {
                b.append(String.format("org.junit.Assert.assertFalse(%s);", call));
            }
        } else if (observer.getOutputType().isPrimitive() && !value.equals(Double.NaN) && !value.equals(Float.NaN)) {
            b.append(String.format("org.junit.Assert.assertEquals(%s, %s);", call, Value.toCodeString(value)));
        } else {
            // string
            // System.out.printf("value = %s - %s%n", value, value.getClass());
            b.append(String.format("org.junit.Assert.assertEquals(%s, %s);", call, Value.toCodeString(value)));
        }
        return b.toString();
    }

    @org.checkerframework.dataflow.qual.Pure
    public boolean evaluate(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this, @org.checkerframework.checker.signature.qual.SignatureUnknown Object@org.checkerframework.checker.signature.qual.SignatureUnknown ... objects) throws Throwable {
        assert objects.length == 0;
        throw new RuntimeException("not implemented.");
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown int getArity(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return 1;
    }

    /**
     * The arguments to which this contract can be applied.
     */
    static @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple inputTypes = new TypeTuple(Arrays.asList(JavaTypes.OBJECT_TYPE));

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.signature.qual.SignatureUnknown TypeTuple getInputTypes(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return inputTypes;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.signature.qual.SignatureUnknown String toCommentString(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return toCodeString();
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.signature.qual.SignatureUnknown String get_observer_str(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return observer.toString();
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public @org.checkerframework.checker.signature.qual.SignatureUnknown String toString(@org.checkerframework.checker.signature.qual.SignatureUnknown ObserverEqValue this) {
        return String.format("<ObserverEqValue %s, value = '%s'", observer, StringsPlume.toStringAndClass(value));
    }
}
