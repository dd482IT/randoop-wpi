package randoop.contract;

import java.util.regex.Matcher;
import randoop.ExecutionOutcome;
import randoop.sequence.Variable;
import randoop.util.ObjectContractReflectionCode;
import randoop.util.ReflectionCode;
import randoop.util.ReflectionExecutor;

/**
 * Utility methods for safely executing and printing {@link ObjectContract} code.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.mustcall.MustCallChecker")
public class ObjectContractUtils {

    @org.checkerframework.dataflow.qual.SideEffectFree
    private ObjectContractUtils() {
        throw new Error("Do not instantiate");
    }

    /**
     * Executes the given contract via reflection.
     *
     * @param c the contract to execute
     * @param objs the list of values to substitute for variables
     * @return the outcome from the execution
     */
    public static @org.checkerframework.checker.mustcall.qual.MustCall({}) ExecutionOutcome execute(final @org.checkerframework.checker.mustcall.qual.MustCall({}) ObjectContract c, final @org.checkerframework.checker.mustcall.qual.MustCall({}) Object@org.checkerframework.checker.mustcall.qual.MustCall({}) ... objs) {
        ReflectionCode refl = new ObjectContractReflectionCode(c, objs);
        return ReflectionExecutor.executeReflectionCode(refl);
    }

    /**
     * Replace dummy variables such as "x0" in the code by their real names.
     *
     * @param str the contract code as a string with dummy variables
     * @param vars list of {@link randoop.sequence.Variable Variable} objects
     * @return the contract code with actual variable names substituted for dummy names
     */
    public static @org.checkerframework.checker.mustcall.qual.MustCall({}) String localizeContractCode(@org.checkerframework.checker.mustcall.qual.MustCall({}) String str, @org.checkerframework.checker.mustcall.qual.MustCall({}) Variable@org.checkerframework.checker.mustcall.qual.MustCall({}) ... vars) {
        for (int i = 0; i < vars.length; i++) {
            // See documentation for ObjectContract.toCommentString().
            String pattern = "\\bx" + i + "\\b";
            str = str.replaceAll(pattern, Matcher.quoteReplacement(vars[i].getName()));
        }
        return str;
    }
}
