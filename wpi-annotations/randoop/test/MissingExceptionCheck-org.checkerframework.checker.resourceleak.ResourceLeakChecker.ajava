package randoop.test;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import org.plumelib.util.CollectionsPlume;
import org.plumelib.util.StringsPlume;
import randoop.Globals;
import randoop.condition.ThrowsClause;

/**
 * Represents the fact that a statement should throw an exception, but did not. It is used in an
 * error-revealing test to indicate that normal execution of the statement violates the stated
 * throws-condition of the method/constructor.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class MissingExceptionCheck implements Check {

    /**
     * The list of lists of throws clauses for which the guard expression was satisfied. Each list of
     * throwsclauses represents one specification, and each such list must be satisfied.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isEmpty" }) List<List<ThrowsClause>> expected;

    /**
     * The index of the statement where the exception should be thrown.
     */
    private final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int index;

    /**
     * Creates a {@link MissingExceptionCheck} object for the expected exception type at the given
     * statement.
     *
     * @param expected the expected exceptions
     * @param index the statement index
     */
    MissingExceptionCheck(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "isEmpty" }) List<List<ThrowsClause>> expected,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int index) {
        this.expected = expected;
        this.index = index;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MissingExceptionCheck this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof MissingExceptionCheck)) {
            return false;
        }
        MissingExceptionCheck other = (MissingExceptionCheck) obj;
        return this.expected.equals(other.expected) && this.index == other.index;
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MissingExceptionCheck this) {
        return Objects.hash(this.expected, this.index);
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.expected" }, methods = { "isEmpty", "iterator" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MissingExceptionCheck this) {
        StringBuilder result = new StringBuilder("MissingExceptionCheck at line " + index + Globals.lineSep);
        for (List<ThrowsClause> set : expected) {
            result.append(set.toString()).append(Globals.lineSep);
        }
        return result.toString();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.expected" }, methods = { "isEmpty", "iterator" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toCodeStringPreStatement(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) MissingExceptionCheck this) {
        StringBuilder msg = new StringBuilder(String.format("// this statement should throw one of%n"));
        for (List<ThrowsClause> exceptionSet : expected) {
            for (ThrowsClause exception : exceptionSet) {
                msg.append(String.format("//   %s %s%n", exception.getExceptionType().getBinaryName(), exception.getComment()));
            }
        }
        return msg.toString();
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.expected" }, methods = { "isEmpty", "iterator", "size" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toCodeStringPostStatement(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "toCodeStringPreStatement" }) MissingExceptionCheck this) {
        List<String> exceptionNameList = new ArrayList<>(expected.size());
        for (List<ThrowsClause> set : expected) {
            List<String> expectedNames = CollectionsPlume.mapList((ThrowsClause exception) -> exception.getExceptionType().getBinaryName(), set);
            exceptionNameList.add("\"[ " + StringsPlume.join(", ", expectedNames) + " ]\"");
        }
        return "org.junit.Assert.fail(\"exception is expected: \" + " + StringsPlume.join(" + ", exceptionNameList) + ");";
    }
}
