package randoop.output;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ParseResult;
import com.github.javaparser.Problem;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Path;
import org.apache.commons.io.FilenameUtils;
import randoop.main.Minimize;
import randoop.main.RandoopBug;
import randoop.main.RandoopUsageError;

/**
 * JavaParser visitor to rename classes.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class ClassRenamingVisitor extends VoidVisitorAdapter<Void> {

    /**
     * The new name.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String oldName;

    /**
     * The new name.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String newName;

    /**
     * Create a ClassRenamingVisitor.
     *
     * @param oldName the old name
     * @param newName the new name
     */
    public ClassRenamingVisitor(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String oldName, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String newName) {
        this.oldName = oldName;
        this.newName = newName;
    }

    // TODO: should rename constructors and uses too, not just the declaration.
    /**
     * Rename the class.
     *
     * @param arg the old and new class names
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getName" })
    public void visit(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassRenamingVisitor this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ClassOrInterfaceDeclaration n, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Void arg) {
        if (n.getName().toString().equals(oldName)) {
            n.setName(newName);
        }
    }

    ///
    /// Static methods
    ///
    /**
     * An instance of a Java parser.
     */
    private static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) JavaParser javaParser = new JavaParser();

    /**
     * Copies a file to a new name, renaming the class. Does not affect the original file.
     *
     * @param file the original Java file
     * @param newClassName the new class name
     * @return the newly-created file
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "getFileName", "resolveSibling", "toFile" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "randoop.output.ClassRenamingVisitor.javaParser" }, methods = { "parse" })
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path copyAndRename(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path file, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String newClassName) {
        CompilationUnit compilationUnit;
        try (FileInputStream inputStream = new FileInputStream(file.toFile())) {
            ParseResult<CompilationUnit> parseCompilationUnit = javaParser.parse(inputStream);
            if (parseCompilationUnit.isSuccessful()) {
                compilationUnit = parseCompilationUnit.getResult().get();
            } else {
                StringBuilder sb = new StringBuilder("Error parsing Java file: ");
                sb.append(file);
                for (Problem problem : parseCompilationUnit.getProblems()) {
                    sb.append(problem);
                }
                throw new RandoopBug(sb.toString());
            }
        } catch (IOException e) {
            throw new RandoopBug("Error reading Java file: " + file, e);
        }
        return copyAndRename(file, compilationUnit, FilenameUtils.removeExtension(file.getFileName().toString()), newClassName);
    }

    /**
     * Copies a file to a new name, renaming the class. Does not affect the original file.
     *
     * @param file the original Java file
     * @param compilationUnit the original Java file, parsed
     * @param oldClassName the old class name
     * @param newClassName the new class name
     * @return the newly-created file
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "resolveSibling", "toFile" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#2" }, methods = { "toString" })
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Path copyAndRename(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "toFile" }) Path file, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CompilationUnit compilationUnit, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String oldClassName, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String newClassName) {
        // Rename the overall class to [original class name][suffix].
        new ClassRenamingVisitor(oldClassName, newClassName).visit(compilationUnit, null);
        // Write the compilation unit to the minimized file.
        Path minimizedFile = file.resolveSibling(newClassName + ".java");
        try {
            Minimize.writeToFile(compilationUnit, minimizedFile);
        } catch (IOException e) {
            throw new RandoopUsageError("Problem while writing file " + minimizedFile, e);
        }
        return minimizedFile;
    }
}
