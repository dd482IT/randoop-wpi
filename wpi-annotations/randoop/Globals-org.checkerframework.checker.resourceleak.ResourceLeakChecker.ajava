package randoop;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Properties;
import org.checkerframework.checker.mustcall.qual.Owning;
import randoop.main.RandoopBug;

/**
 * Various general global variables used throughout Randoop.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class Globals {

    /**
     * The version number for Randoop.
     */
    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String RANDOOP_VERSION = "4.3.2";

    /**
     * The system-specific line separator string.
     */
    public static final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String lineSep = System.lineSeparator();

    /**
     * A PrintStream whose contents are ignored.
     */
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) PrintStream blackHole = new PrintStream(new NullOutputStream());

    /**
     * Discards anything written to it.
     */
    private static class NullOutputStream extends OutputStream {

        @org.checkerframework.dataflow.qual.Pure
        public void write(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) NullOutputStream this,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int b) throws IOException {
        }
    }

    /**
     * Return the version number for Randoop.
     *
     * @return the version number for Randoop
     */
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getRandoopVersion() {
        Properties prop = new Properties();
        try (InputStream isReleaseStream = Globals.class.getResourceAsStream("/this-is-a-randoop-release")) {
            if (isReleaseStream != null) {
                return RANDOOP_VERSION;
            }
        } catch (IOException e) {
            throw new RandoopBug(e);
        }
        try (InputStream inputStream = Globals.class.getResourceAsStream("/git.properties")) {
            prop.load(inputStream);
        } catch (IOException e) {
            throw new RandoopBug(e);
        }
        String localChanges = prop.getProperty("git.dirty").equals("true") ? ", local changes" : "";
        return "\"" + String.join(", ", RANDOOP_VERSION + localChanges, "branch " + prop.getProperty("git.branch"), "commit " + prop.getProperty("git.commit.id.abbrev"), prop.getProperty("git.commit.time").substring(0, 10)) + "\"";
    }

    /**
     * Return the Java classpath.
     *
     * @return the Java classpath
     */
    @org.checkerframework.dataflow.qual.Pure
    public static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getClassPath() {
        return System.getProperty("java.class.path");
    }

    /**
     * Column width for printing messages.
     */
    public static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int COLWIDTH = 70;

    /**
     * Number of spaces for leading indentation for printing messages.
     */
    public static final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int INDENTWIDTH = 8;
}
