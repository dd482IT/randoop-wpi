package randoop.compile;

import static randoop.compile.CompileUtil.toURI;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import javax.tools.SimpleJavaFileObject;

/**
 * A {@code JavaFileObject} for source code in memory.
 *
 * <p>based on {@code javaxtools.compiler.JavaFileObjectImple} from <a
 * href="http://web.archive.org/web/20170202133304/https://www.ibm.com/developerworks/library/j-jcomp/index.html">Create
 * dynamic applications with javax.tools</a>.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
class SequenceJavaFileObject extends SimpleJavaFileObject {

    /**
     * The source code text.
     */
    private final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String source;

    /**
     * The stream for reading the source code.
     */
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) ByteArrayOutputStream byteStream;

    /**
     * Creates a {@link SequenceJavaFileObject} for the given class name and kind.
     *
     * @param classFileName the name of the class
     * @param kind either {@code SOURCE} or {@code CLASS}
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.source" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    SequenceJavaFileObject(final String classFileName, final Kind kind) {
        super(toURI(classFileName), kind);
        this.source = null;
    }

    /**
     * Creates a {@link SequenceJavaFileObject} with the given name and class source.
     *
     * @param classFileName the name of the class
     * @param sequenceClass the class source
     */
    SequenceJavaFileObject(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String classFileName, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String sequenceClass) {
        super(toURI(classFileName), Kind.SOURCE);
        this.source = sequenceClass;
    }

    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) CharSequence getCharContent(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SequenceJavaFileObject this, final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean ignoreEncodingErrors) throws UnsupportedOperationException {
        if (source == null) {
            throw new UnsupportedOperationException("getCharContent()");
        }
        return source;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getByteCode" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.byteStream" }, methods = { "toByteArray" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) InputStream openInputStream(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SequenceJavaFileObject this) {
        return new ByteArrayInputStream(getByteCode());
    }

    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) OutputStream openOutputStream(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SequenceJavaFileObject this) {
        byteStream = new ByteArrayOutputStream();
        return byteStream;
    }

    /**
     * Returns the byte stream as a byte array.
     *
     * @return the byte array for the byte stream
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.byteStream" }, methods = { "toByteArray" })
     @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) byte @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) [] getByteCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) SequenceJavaFileObject this) {
        return byteStream.toByteArray();
    }
}
