package randoop.compile;

import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;
import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.ToolProvider;
import org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods;
import org.checkerframework.checker.mustcall.qual.MustCall;
import org.checkerframework.checker.mustcall.qual.Owning;
import org.checkerframework.checker.signature.qual.BinaryName;
import org.checkerframework.checker.signature.qual.BinaryNameWithoutPackage;
import org.checkerframework.checker.signature.qual.DotSeparatedIdentifiers;
import org.plumelib.reflection.ReflectionPlume;
import randoop.Globals;
import randoop.main.RandoopBug;
import randoop.main.RandoopUsageError;

/**
 * Compiles a Java class given as a {@code String}.
 *
 * <p>A simplified version of the {@code javaxtools.compiler.CharSequenceCompiler} from <a
 * href="http://web.archive.org/web/20170202133304/https://www.ibm.com/developerworks/library/j-jcomp/index.html">Create
 * dynamic applications with javax.tools</a>.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.signature.SignatureChecker")
public class SequenceCompiler implements Closeable {

    /**
     * If non-null, do verbose output for compilation failures where the Java source code contains the
     * string.
     */
    private static final String debugCompilationFailure = null;

    /**
     * The options to the compiler.
     */
    private final @org.checkerframework.checker.signature.qual.SignatureUnknown List<String> compilerOptions;

    /**
     * the Java compiler
     */
    private final @org.checkerframework.checker.signature.qual.SignatureUnknown JavaCompiler compiler;

    /**
     * The {@code FileManager} for this compiler.
     */
    private final @org.checkerframework.checker.signature.qual.SignatureUnknown JavaFileManager fileManager;

    /**
     * Creates a {@link SequenceCompiler}.
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    public SequenceCompiler() {
        this(new ArrayList<String>(0));
    }

    /**
     * Creates a {@link SequenceCompiler}.
     *
     * @param compilerOptions the compiler options
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    public SequenceCompiler(@org.checkerframework.checker.signature.qual.SignatureUnknown List<String> compilerOptions) {
        this.compilerOptions = new ArrayList<>(compilerOptions.size() + 3);
        this.compilerOptions.addAll(compilerOptions);
        this.compilerOptions.add("-XDuseUnsharedTable");
        this.compilerOptions.add("-d");
        this.compilerOptions.add(".");
        this.compiler = ToolProvider.getSystemJavaCompiler();
        if (this.compiler == null) {
            throw new RandoopUsageError("Cannot find the Java compiler. Check that classpath includes tools.jar." + Globals.lineSep + "Classpath:" + Globals.lineSep + ReflectionPlume.classpathToString());
        }
        this.fileManager = compiler.getStandardFileManager(null, null, null);
    }

    /**
     * Releases any system resources associated with this.
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    public void close(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this) throws IOException {
        fileManager.close();
    }

    /**
     * Indicates whether the given class is compilable.
     *
     * @param packageName the package name for the class, null if default package
     * @param classname the simple name of the class
     * @param javaSource the source text of the class
     * @return true if class source was successfully compiled, false otherwise
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    public  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean isCompilable(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this, final @org.checkerframework.checker.signature.qual.SignatureUnknown String packageName, final @org.checkerframework.checker.signature.qual.Identifier String classname, final @org.checkerframework.checker.signature.qual.SignatureUnknown String javaSource) {
        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
        boolean result = compile(packageName, classname, javaSource, diagnostics);
        // Compilation can create multiple .class files; this only deletes the main one.
        Path dir = Paths.get((packageName == null) ? "." : packageName.replace(".", "/"));
        try {
            Files.delete(dir.resolve(classname + ".class"));
        } catch (NoSuchFileException e) {
            // Nothing to do, but I wonder why the file doesn't exist.
        } catch (IOException e) {
            System.out.printf("Unable to delete %s: %s%n", dir.resolve(classname + ".class").toAbsolutePath(), e);
        }
        if (!result && debugCompilationFailure != null && javaSource.contains(debugCompilationFailure)) {
            StringJoiner sj = new StringJoiner(Globals.lineSep);
            sj.add("isCompilable => false");
            for (Diagnostic<?> d : diagnostics.getDiagnostics()) {
                sj.add(d.toString());
            }
            sj.add(javaSource);
            System.out.println(sj.toString());
        }
        return result;
    }

    /**
     * Compiles the given class. If this method returns normally, compilation was successful.
     *
     * @param packageName the package of the class, null if default package
     * @param classname the simple name of the class
     * @param javaSource the source text of the class
     * @throws SequenceCompilerException if the compilation fails
     */
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    private void compile(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this, final @org.checkerframework.checker.signature.qual.SignatureUnknown String packageName, final @org.checkerframework.checker.signature.qual.Identifier String classname, final @org.checkerframework.checker.signature.qual.SignatureUnknown String javaSource) throws SequenceCompilerException {
        DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
        boolean success = compile(packageName, classname, javaSource, diagnostics);
        if (!success) {
            throw new SequenceCompilerException("Compilation failed", javaSource, diagnostics);
        }
    }

    /**
     * A helper method for the {@link #compile(String, String, String)} and {@link
     * #isCompilable(String, String, String)} methods: compiles the given class using the given
     * diagnostics collector.
     *
     * @param packageName the package of the class, null if default package
     * @param classname the simple name of the class
     * @param javaSource the source text of the class
     * @param diagnostics the {@code DiagnosticsCollector} object to use for the compilation. Always
     *     use a new diagnostics collector each compilation to avoid accumulating errors.
     * @return true if the class source is successfully compiled, false otherwise
     */
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    private  @org.checkerframework.checker.signature.qual.SignatureUnknown boolean compile(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this, final @org.checkerframework.checker.signature.qual.SignatureUnknown String packageName, final @org.checkerframework.checker.signature.qual.Identifier String classname, final @org.checkerframework.checker.signature.qual.SignatureUnknown String javaSource, @org.checkerframework.checker.signature.qual.SignatureUnknown DiagnosticCollector<JavaFileObject> diagnostics) {
        String classFileName = classname + ".java";
        List<JavaFileObject> sources = new ArrayList<>(1);
        JavaFileObject source = new SequenceJavaFileObject(classFileName, javaSource);
        sources.add(source);
        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, new ArrayList<String>(compilerOptions), null, sources);
        Boolean succeeded = task.call();
        return (succeeded != null && succeeded);
    }

    /**
     * Compiles the given class, leads it, and returns the Class object. If this method returns
     * normally, compilation was successful.
     *
     * @param packageName the package of the class, null if default package
     * @param classname the simple name of the class
     * @param javaSource the source text of the class
     * @throws SequenceCompilerException if the compilation fails
     * @return the loaded Class object
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    public @org.checkerframework.checker.signature.qual.SignatureUnknown Class<?> compileAndLoad(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this, final @org.checkerframework.checker.signature.qual.DotSeparatedIdentifiers String packageName, final @org.checkerframework.checker.signature.qual.Identifier String classname, final @org.checkerframework.checker.signature.qual.SignatureUnknown String javaSource) throws SequenceCompilerException {
        compile(packageName, classname, javaSource);
        String fqName = fullyQualifiedName(packageName, classname);
        File dir = new File("").getAbsoluteFile();
        return loadClassFile(dir, fqName);
    }

    /**
     * Given a .class file, returns the corresponding Class object.
     *
     * @param directory the directory containing the .class file (possibly in a package-named
     *     subdirectory)
     * @param className the binary name of the class defined in the file
     * @return the loaded Class object
     */
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    private static @org.checkerframework.checker.signature.qual.SignatureUnknown Class<?> loadClassFile(@org.checkerframework.checker.signature.qual.SignatureUnknown File directory, @org.checkerframework.checker.signature.qual.SignatureUnknown String className) {
        try (URLClassLoader cl = new URLClassLoader(new URL[] { directory.toURI().toURL() })) {
            Class<?> cls = cl.loadClass(className);
            return cls;
        } catch (ClassNotFoundException | NoClassDefFoundError | IOException e) {
            throw new RandoopBug(e);
        }
    }

    /**
     * Constructs a fully-qualified class name from the given package and unqualified class name.
     *
     * @param packageName the package of the class, null if default package
     * @param classname the name of the class, without the package
     * @return the fully-qualified class name constructed from the arguments
     */
    @org.checkerframework.framework.qual.RequiresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "randoop.compile.SequenceCompiler.debugCompilationFailure" }, qualifier = org.checkerframework.checker.signature.qual.SignatureBottom.class)
    @org.checkerframework.dataflow.qual.Pure
    @org.checkerframework.checker.signature.qual.SignatureUnknown String fullyQualifiedName(@org.checkerframework.checker.signature.qual.SignatureUnknown SequenceCompiler this, @org.checkerframework.checker.signature.qual.SignatureUnknown String packageName, @org.checkerframework.checker.signature.qual.Identifier String classname) {
        String result = (packageName == null ? "" : (packageName + ".")) + classname;
        return result;
    }
}
