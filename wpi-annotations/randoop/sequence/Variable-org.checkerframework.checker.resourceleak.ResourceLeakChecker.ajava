package randoop.sequence;

import randoop.types.Type;

/**
 * Represents the result of a statement call in a sequence.
 */
@org.checkerframework.framework.qual.AnnotatedFor("org.checkerframework.checker.resourceleak.ResourceLeakChecker")
public class Variable implements Comparable<Variable> {

    // The index of the statement that creates this value.
    public final  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int index;

    // The sequence that creates this value.
    public final @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Sequence sequence;

    public Variable(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Sequence owner,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int i) {
        if (owner == null)
            throw new IllegalArgumentException("missing owner");
        if (i < 0) {
            throw new IllegalArgumentException("negative index: " + i);
        }
        this.sequence = owner;
        this.index = i;
    }

    /**
     * Do not use! Only for use by DummyVariable.
     */
    @org.checkerframework.framework.qual.EnsuresQualifier(expression = { "this.sequence" }, qualifier = org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom.class)
    protected Variable() {
        index = 0;
        sequence = null;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getName", "getType" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "getStatement", "getStatementWithInputs", "getStatementsWithInputs", "isValidIndex", "size" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String toString(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this) {
        return this.getName();
    }

    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean equals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof Variable)) {
            return false;
        }
        Variable other = (Variable) o;
        // Two values are equal only if they are owned by the
        // same sequence, where "same" means the same reference.
        // return this.sequence == other.sequence && this.index == other.index;
        return this.index == other.index;
    }

    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "hashCode" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int hashCode(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this) {
        return this.index * this.sequence.hashCode();
    }

    /**
     * Returns the type of this variable.
     *
     * @return the type of this variable
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "getStatement", "getStatementWithInputs", "getStatementsWithInputs", "isValidIndex", "size" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type getType(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this) {
        return this.sequence.getStatement(index).getOutputType();
    }

    /**
     * The statement that produced this variable.
     *
     * @return the statement to which this variable belongs
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "getStatement", "getStatementWithInputs", "getStatementsWithInputs", "isValidIndex", "size" })
    @org.checkerframework.dataflow.qual.Pure
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Statement getDeclaringStatement(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getName", "getType", "shouldInlineLiterals" }) Variable this) {
        return this.sequence.getStatement(index);
    }

    /**
     * The index of the statement that creates this value.
     *
     * @return the statement index where this variable is created
     */
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int getDeclIndex(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this) {
        return this.index;
    }

    /*
  public Variable copyWithIndexUpdated(Map<Integer, Integer> map) {
    return new Variable(sequence, map.get(index));
  }

  public static List<Integer> statementIndexList(List<Variable> values) {
    return CollectionsPlume.mapList(Variable::getDeclIndex, values);
  }
  */
    /**
     * Returns the name of this variable.
     *
     * @return the name of this variable as a string
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this" }, methods = { "getName", "getType" })
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "getStatement", "getStatementWithInputs", "getStatementsWithInputs", "isValidIndex", "size" })
    public @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this) {
        return getName(classToVariableName(getType()), index);
    }

    /**
     * The name of this variable using the given type name and index.
     *
     * @param className the classname to use
     * @param i the index to use in the name
     * @return the variable name that appends the index to the classname
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "charAt", "substring" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    private @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String getName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String className,  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int i) {
        String basename = classNameToVariableName(className);
        return basename + Integer.toString(i);
    }

    @org.checkerframework.dataflow.qual.SideEffectFree
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) int compareTo(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable this, @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Variable o) {
        if (o == null)
            throw new IllegalArgumentException();
        if (o.sequence != this.sequence)
            throw new IllegalArgumentException();
        return Integer.valueOf(this.index).compareTo(o.index);
    }

    /**
     * Build a variable name from the name of the given type.
     *
     * @param type the type
     * @return the variable name as a string
     */
    static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String classToVariableName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) Type type) {
        return VariableRenamer.getVariableName(type);
    }

    /**
     * Convert the classname to a variable name, preserving camel case if used.
     *
     * @param className the class name
     * @return the variable form of the classname
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "#1" }, methods = { "charAt", "substring" })
    @org.checkerframework.dataflow.qual.SideEffectFree
    private static @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String classNameToVariableName(@org.checkerframework.checker.calledmethods.qual.CalledMethods({}) String className) {
        assert !className.contains(".");
        assert !className.contains("[");
        assert !className.equals("");
        return Character.toLowerCase(className.charAt(0)) + className.substring(1);
    }

    /**
     * True if this variable's value should be inlined as a literal at call sites, rather than
     * referencing the variable.
     *
     * @return whether this variable's value should be inlined as a literal at call sites
     */
    @org.checkerframework.checker.calledmethods.qual.EnsuresCalledMethods(value = { "this.sequence" }, methods = { "shouldInlineLiterals" })
    @org.checkerframework.dataflow.qual.Pure
    public  @org.checkerframework.checker.calledmethods.qual.CalledMethods({}) boolean shouldInlineLiterals(@org.checkerframework.checker.calledmethods.qual.CalledMethods({ "getName", "getType" }) Variable this) {
        return sequence.shouldInlineLiterals();
    }
}
